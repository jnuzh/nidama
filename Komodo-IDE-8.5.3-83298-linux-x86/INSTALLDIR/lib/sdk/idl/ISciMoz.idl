/* Copyright (c) 2000-2006 ActiveState Software Inc.
   See the file LICENSE.txt for licensing information. */

// ISciMoz.idl
// Interface to the Scintilla Mozilla plugin.
// Author: Neil Hodgson

// *************** This is *NOT* a valid IDL file. *****************
// It is a template from which a valid IDL file is generated.
// *****************************************************************

#include "nsISupports.idl"
#include "nsIDOMEvent.idl"

interface ISciMozEvents;
interface nsIVariant; // Needed for generated code
// An interface purely to get around a 128 vtable limitation
// on some parts of xpcom.
// This is pretty much all methods available in C++ (or python) due to the split
// interfaces.  See Mozilla bug 54471
// If you need some other calls, add them in XPFacer.py, in the liteFeatures list.
// There is a maximum number of entries we'll be able to use here until the Moz
// bug is fixed.
[scriptable, uuid(5f8641d6-def9-4236-a77d-63b46fb34386)]
interface ISciMozLite : nsISupports {
	// Manually created features
	attribute DOMString name; // a "name" for debugging/diagnostic purposes.
	void hookEvents(in ISciMozEvents eventListener, [optional] in long mask);
	void unhookEvents(in ISciMozEvents eventListener);
	// this one is more of a hack to avoid exposing the
	// non-scriptable nsIDOMWindow to Python!
	void sendUpdateCommands(in string commandset);
	void getStyledText(in long min, in long max, out unsigned long count, 
		[array, size_is(count), retval] out octet str);
	void getStyleRange(in long min, in long max, [optional] out unsigned long count,
			   [array, size_is(count), retval] out unsigned short styles);
	long getCurLine(out AString text);
	void assignCmdKey(in long key, in long modifiers, in long msg);
	void clearCmdKey(in long key, in long modifiers);

	/**
	 * Get the text in the specified range
	 * The parameters are byte positions
	 */
	AString getTextRange(in long min, in long max);
	attribute AString text;
	/**
	 * The textHasChanged attribute is set to true whenever the Scintilla
	 * text is modified. This is so the JavaScript SciMoz wrapper can keep
	 * a cached copy of the text without having to go through XPCOM and
	 * Scintilla each time.
	 */
	readonly attribute boolean textHasChanged;
	readonly attribute AString selText;
	
	// stuff to minimize some of our eventist usage
	void doBraceMatch();
	
        // utility function to save every man and his dog from doing the int->char conversion.
        wchar getWCharAt(in long pos);
        // Indicates if Scintilla is currently "owned" by the plugin instance.
        // ie, if it is "visible".  However, "visible" is too overloaded (ie, could
        // mean simply scrolled out of view, so went for this!
        readonly attribute boolean isOwned;
        
        // computes the char position for the current byte position
        // if position < 0 then the currentPos is used
        long charPosAtPosition(in long position);
        
        // Is the underlying Window visible?  (To prevent paint flicker as we
        // init the control, MSWindows creates the Windows invisible, and never
        // automatically sets it to visible - this property *must* be set.)
        attribute boolean visible;
    
        attribute boolean isFocused;

        // Mark the instance as closed, no communications should travel to/from
	// the scimoz instance after this point.
        void markClosed();

        void addChar(in uint32_t ch);
        long getLine(in long line, out AUTF8String text);
	
        // Needed on linux because of the way Mozilla works...
        // We do a grab_add on mousedown, but if you start dragging after that,
        // the widget never receives a mouseup and thus we never do a
        // grab_remove.. here is our chance.
        void endDrop();











	// used to prevent context menu's on the scrollbars while scrollbar
	// tracking is occuring
	readonly attribute boolean isTracking;
        // used on OSX to see if scintilla initiated a drag session
        readonly attribute boolean inDragSession;

	// Read-write wrapper for SCI_SETWORDCHARS
	attribute AUTF8String wordChars;
	// Backwards-compatibility alias for ISciMozLite.wordChars = "xxx";
	// (It used to be ISciMozLite.setWordChars("xxx"); )
	[deprecated, binaryname(SetWordChars_backCompat)]
	void setWordChars(in AUTF8String characters);

//++Autogenerated
// BEGIN GENERATED SECTION - ISciMoz.idl - "lite" interface
// All code in this section has been automatically generated.
// DO NOT EDIT THIS SECTION

        // Add text to the document at current position.
        void addText(in nsIVariant text_or_length, [optional] in AUTF8String text_deprecated);
        // Insert string at a position.
        void insertText(in long pos, in AUTF8String text);
        // Returns the number of bytes in the document.
        readonly attribute long length;
        // Returns the position of the caret.
        attribute long currentPos;
        // Returns the position of the opposite end of the selection to the caret.
        attribute long anchor;
        // Select all the text in the document.
        void selectAll();
        // Is undo history being collected?
        attribute boolean undoCollection;
        // Set caret to start of a line and ensure it is visible.
        void gotoLine(in long line);
        // Set caret to a position and ensure it is visible.
        void gotoPos(in long pos);
        // Set the current styling position to pos and the styling mask to mask.
        // The styling mask can be used to protect some bits in each styling byte from modification.
        void startStyling(in long pos, in long mask);
        // Change style from current styling position for length characters to a style
        // and move the current styling position to after this newly styled segment.
        void setStyling(in long length, in long style);
        // Add a marker to a line, returning an ID which can be used to find or delete the marker.
        long markerAdd(in long line, in long markerNumber);
        // Find the next line at or after lineStart that includes a marker in mask.
        // Return -1 when no more lines.
        long markerNext(in long lineStart, in long markerMask);
        // Add a set of markers to a line.
        void markerAddSet(in long line, in long set);
        // Set the foreground colour of a style.
        void styleSetFore(in long style, in long fore);
        // Start a sequence of actions that is undone and redone as a unit.
        // May be nested.
        void beginUndoAction();
        // End a sequence of actions that is undone and redone as a unit.
        void endUndoAction();
        // Get the position after the last visible characters on a line.
        long getLineEndPosition(in long line);
        // In read-only mode?
        attribute boolean readOnly;
        // Returns the position at the start of the selection.
        attribute long selectionStart;
        // Returns the position at the end of the selection.
        attribute long selectionEnd;
        // Draw the selection in normal style or with selection highlighted.
        void hideSelection(in boolean normal);
        // Retrieve the x value of the point in the window where a position is displayed.
        long pointXFromPosition(in long pos);
        // Retrieve the y value of the point in the window where a position is displayed.
        long pointYFromPosition(in long pos);
        // Retrieve the line containing a position.
        long lineFromPosition(in long pos);
        // Retrieve the position at the start of a line.
        long positionFromLine(in long line);
        // Replace the selected text with the argument text.
        void replaceSel(in AUTF8String text);
        // Undo one action in the undo history.
        void undo();
        // Retrieve the document width assumed for scrolling.
        attribute long scrollWidth;
        // Retrieve the height of a particular line of text in pixels.
        long textHeight(in long line);
        // Delete the selection or if no selection, the character before the caret.
        void deleteBack();
        // Insert a new line, may use a CRLF, CR or LF depending on EOL mode.
        void newLine();
        // Get and Set the xOffset (ie, horizontal scroll position).
        attribute long xOffset;
        // Given a valid document position, return the next position taking code
        // page into account. Maximum value returned is the last position in the document.
        long positionAfter(in long pos);
        // Find the position of a character from a point within the window.
        // Return INVALID_POSITION if not close to text.
        long charPositionFromPointClose(in long x, in long y);
        // Returns the position of the character.
        long positionAtChar(in long start, in long charoffset);


// END GENERATED SECTION.
//--Autogenerated

};

//++Autogenerated
// BEGIN GENERATED SECTION - ISciMoz.idl - "standard" interfaces
// All code in this section has been automatically generated.
// DO NOT EDIT THIS SECTION

[scriptable, uuid(a53c386b-99e2-4b2e-85e7-fb5a29322369)]
interface ISciMoz_Part0 : nsISupports {
        // Add array of cells to document.
        void addStyledText(in nsIVariant text_or_length, [optional] in AUTF8String text_deprecated);
        // Delete all text in the document.
        void clearAll();
        // Delete a range of text in the document.
        void deleteRange(in long pos, in long deleteLength);
        // Set all style bytes to 0, remove all folding information.
        void clearDocumentStyle();
        // Returns the character byte at the position.
        long getCharAt(in long pos);
        // Returns the style byte at the position.
        long getStyleAt(in long pos);
        // Redoes the next action on the undo history.
        void redo();
        // Remember the current position in the undo history as the position
        // at which the document was saved.
        void setSavePoint();
        // Are there any redoable actions in the undo history?
        boolean canRedo();
        // Retrieve the line number at which a particular marker is located.
        long markerLineFromHandle(in long handle);
        // Delete a marker.
        void markerDeleteHandle(in long handle);
        // Are white space characters currently visible?
        // Returns one of SCWS_* constants.
        attribute long viewWS;
        // Find the position from a point within the window.
        long positionFromPoint(in long x, in long y);
        // Find the position from a point within the window but return
        // INVALID_POSITION if not close to text.
        long positionFromPointClose(in long x, in long y);
        // Retrieve the position of the last correctly styled character.
        readonly attribute long endStyled;
        // Convert all line endings in the document to one mode.
        void convertEOLs(in long eolMode);
        // Retrieve the current end of line mode - one of CRLF, CR, or LF.
        attribute long eOLMode;
        // Is drawing done first into a buffer or direct to the screen?
        attribute boolean bufferedDraw;
        // Retrieve the visible size of a tab.
        attribute long tabWidth;
        // Set the symbol used for a particular marker number.
        void markerDefine(in long markerNumber, in long markerSymbol);
        // Set the foreground colour used for a particular marker number.
        void markerSetFore(in long markerNumber, in long fore);
        // Set the background colour used for a particular marker number.
        void markerSetBack(in long markerNumber, in long back);
        // Set the background colour used for a particular marker number when its folding block is selected.
        void markerSetBackSelected(in long markerNumber, in long back);
        // Enable/disable highlight for current folding bloc (smallest one that contains the caret)
        void markerEnableHighlight(in boolean enabled);
        // Delete a marker from a line.
        void markerDelete(in long line, in long markerNumber);
        // Delete all markers with a particular number from all lines.
        void markerDeleteAll(in long markerNumber);
        // Get a bit mask of all the markers set on a line.
        long markerGet(in long line);
        // Find the previous line before lineStart that includes a marker in mask.
        long markerPrevious(in long lineStart, in long markerMask);
        // Define a marker from a pixmap.
        void markerDefinePixmap(in long markerNumber, in AUTF8String pixmap);
        // Set the alpha used for a marker that is drawn in the text area, not the margin.
        void markerSetAlpha(in long markerNumber, in long alpha);
        // Set a margin to be either numeric or symbolic.
        void setMarginTypeN(in long margin, in long marginType);
        // Retrieve the type of a margin.
        long getMarginTypeN(in long margin);
        // Set the width of a margin to a width expressed in pixels.
        void setMarginWidthN(in long margin, in long pixelWidth);
        // Retrieve the width of a margin in pixels.
        long getMarginWidthN(in long margin);
        // Set a mask that determines which markers are displayed in a margin.
        void setMarginMaskN(in long margin, in long mask);
        // Retrieve the marker mask of a margin.
        long getMarginMaskN(in long margin);
        // Make a margin sensitive or insensitive to mouse clicks.
        void setMarginSensitiveN(in long margin, in boolean sensitive);
        // Retrieve the mouse click sensitivity of a margin.
        boolean getMarginSensitiveN(in long margin);
        // Set the cursor shown when the mouse is inside a margin.
        void setMarginCursorN(in long margin, in long cursor);
        // Retrieve the cursor shown in a margin.
        long getMarginCursorN(in long margin);
        // Clear all the styles and make equivalent to the global default style.
        void styleClearAll();
        // Set the background colour of a style.
        void styleSetBack(in long style, in long back);
        // Set a style to be bold or not.
        void styleSetBold(in long style, in boolean bold);
        // Set a style to be italic or not.
        void styleSetItalic(in long style, in boolean italic);
        // Set the size of characters of a style.
        void styleSetSize(in long style, in long sizePoints);
        // Set the font of a style.
        void styleSetFont(in long style, in AUTF8String fontName);
        // Set a style to have its end of line filled or not.
        void styleSetEOLFilled(in long style, in boolean filled);
        // Reset the default style to its state at startup
        void styleResetDefault();
        // Set a style to be underlined or not.
        void styleSetUnderline(in long style, in boolean underline);
        // Get the foreground colour of a style.
        long styleGetFore(in long style);
        // Get the background colour of a style.
        long styleGetBack(in long style);
        // Get is a style bold or not.
        boolean styleGetBold(in long style);
        // Get is a style italic or not.
        boolean styleGetItalic(in long style);
        // Get the size of characters of a style.
        long styleGetSize(in long style);
        // Get the font of a style.
        // Returns the length of the fontName
        long styleGetFont(in long style, out AString fontName);
        // Get is a style to have its end of line filled or not.
        boolean styleGetEOLFilled(in long style);
        // Get is a style underlined or not.
        boolean styleGetUnderline(in long style);
        // Get is a style mixed case, or to force upper or lower case.
        long styleGetCase(in long style);
        // Get the character get of the font in a style.
        long styleGetCharacterSet(in long style);
        // Get is a style visible or not.
        boolean styleGetVisible(in long style);
        // Get is a style changeable or not (read only).
        // Experimental feature, currently buggy.
        boolean styleGetChangeable(in long style);
        // Get is a style a hotspot or not.
        boolean styleGetHotSpot(in long style);
        // Set a style to be mixed case, or to force upper or lower case.
        void styleSetCase(in long style, in long caseForce);
        // Set the size of characters of a style. Size is in points multiplied by 100.
        void styleSetSizeFractional(in long style, in long caseForce);
        // Get the size of characters of a style in points multiplied by 100
        long styleGetSizeFractional(in long style);
        // Set the weight of characters of a style.
        void styleSetWeight(in long style, in long weight);
        // Get the weight of characters of a style.
        long styleGetWeight(in long style);
        // Set the character set of the font in a style.
        void styleSetCharacterSet(in long style, in long characterSet);
        // Set a style to be a hotspot or not.
        void styleSetHotSpot(in long style, in boolean hotspot);
        // Set the foreground colour of the main and additional selections and whether to use this setting.
        void setSelFore(in boolean useSetting, in long fore);
        // Set the background colour of the main and additional selections and whether to use this setting.
        void setSelBack(in boolean useSetting, in long back);
        // Get the alpha of the selection.
        attribute long selAlpha;
        // Is the selection end of line filled?
        attribute boolean selEOLFilled;
        // Drop all key mappings.
        void clearAllCmdKeys();
        // Set the styles for a segment of the document.
        void setStylingEx(in long length, in AUTF8String styles);
        // Set a style to be visible or not.
        void styleSetVisible(in long style, in boolean visible);
        // Get the time in milliseconds that the caret is on and off.
        attribute long caretPeriod;
        // Set an indicator to plain, squiggle or TT.
        void indicSetStyle(in long indic, in long style);
        // Retrieve the style of an indicator.
        long indicGetStyle(in long indic);
        // Set the foreground colour of an indicator.
        void indicSetFore(in long indic, in long fore);
        // Retrieve the foreground colour of an indicator.
        long indicGetFore(in long indic);
        // Set an indicator to draw under text or over(default).
        void indicSetUnder(in long indic, in boolean under);
        // Retrieve whether indicator drawn under or over text.
        boolean indicGetUnder(in long indic);
        // Set the foreground colour of all whitespace and whether to use this setting.
        void setWhitespaceFore(in boolean useSetting, in long fore);
        // Set the background colour of all whitespace and whether to use this setting.
        void setWhitespaceBack(in boolean useSetting, in long back);
        // Get the size of the dots used to mark space characters.
        attribute long whitespaceSize;
        // Retrieve number of bits in style bytes used to hold the lexical state.
        attribute long styleBits;
        // Used to hold extra styling information for each line.
        void setLineState(in long line, in long state);
        // Retrieve the extra styling information for a line.
        long getLineState(in long line);
        // Retrieve the last line number that has line state.
        readonly attribute long maxLineState;
        // Is the background of the line containing the caret in a different colour?
        attribute boolean caretLineVisible;
        // Get the colour of the background of the line containing the caret.
        attribute long caretLineBack;
        // Set a style to be changeable or not (read only).
        // Experimental feature, currently buggy.
        void styleSetChangeable(in long style, in boolean changeable);
        // Display a auto-completion list.
        // The lenEntered parameter indicates how many characters before
        // the caret should be used to provide context.
        void autoCShow(in long lenEntered, in AUTF8String itemList);
        // Remove the auto-completion list from the screen.
        void autoCCancel();
        // Is there an auto-completion list visible?
        boolean autoCActive();
        // Retrieve the position of the caret when the auto-completion list was displayed.
        long autoCPosStart();
        // User has selected an item so remove the list and insert the selection.
        void autoCComplete();
        // Define a set of character that when typed cancel the auto-completion list.
        void autoCStops(in AUTF8String characterSet);
        // Retrieve the auto-completion list separator character.
        attribute long autoCSeparator;
        // Select the item in the auto-completion list that starts with a string.
        void autoCSelect(in AUTF8String text);
        // Retrieve whether auto-completion cancelled by backspacing before start.
        attribute boolean autoCCancelAtStart;
        // Define a set of characters that when typed will cause the autocompletion to
        // choose the selected item.
        void autoCSetFillUps(in AUTF8String characterSet);
        // Retrieve whether a single item auto-completion list automatically choose the item.
        attribute boolean autoCChooseSingle;
        // Retrieve state of ignore case flag.
        attribute boolean autoCIgnoreCase;
        // Display a list of strings and send notification when user chooses one.
        void userListShow(in long listType, in AUTF8String itemList);
        // Retrieve whether or not autocompletion is hidden automatically when nothing matches.
        attribute boolean autoCAutoHide;
        // Retrieve whether or not autocompletion deletes any word characters
        // after the inserted text upon completion.
        attribute boolean autoCDropRestOfWord;
        // Register an XPM image for use in autocompletion lists.
        void registerImage(in long type, in AUTF8String xpmData);
        // Clear all the registered XPM images.
        void clearRegisteredImages();
        // Retrieve the auto-completion list type-separator character.
        attribute long autoCTypeSeparator;
        // Get the maximum width, in characters, of auto-completion and user lists.
        attribute long autoCMaxWidth;
        // Set the maximum height, in rows, of auto-completion and user lists.
        attribute long autoCMaxHeight;
        // Retrieve indentation size.
        attribute long indent;
        // Retrieve whether tabs will be used in indentation.
        attribute boolean useTabs;
        // Change the indentation of a line to a number of columns.
        void setLineIndentation(in long line, in long indentSize);
        // Retrieve the number of columns that a line is indented.
        long getLineIndentation(in long line);
        // Retrieve the position before the first non indentation character on a line.
        long getLineIndentPosition(in long line);
        // Retrieve the column number of a position, taking tab width into account.
        long getColumn(in long pos);
        // Count characters between two positions.
        long countCharacters(in long startPos, in long endPos);
        // Is the horizontal scroll bar visible?
        attribute boolean hScrollBar;
        // Turn on custom (owner-drawn) scroll bars.  All necessary calculations will
        // still be done, it just won't be shown.  Note that this applies to both
        // horizontal and vertical scroll bars.
        attribute boolean useCustomScrollBars;
        // Are the indentation guides visible?
        attribute long indentationGuides;
        // Get the highlighted indentation guide column.
        attribute long highlightGuide;
        // Get the code page used to interpret the bytes of the document as characters.
        attribute long codePage;
};
[scriptable, uuid(4645e5bd-4cd1-44dc-9d70-00b38dc87d29)]
interface ISciMoz_Part1 : nsISupports {
        // Get the foreground colour of the caret.
        attribute long caretFore;
        // Set caret to a position, while removing any existing selection.
        void setEmptySelection(in long pos);
        // Returns the print magnification.
        attribute long printMagnification;
        // Returns the print colour mode.
        attribute long printColourMode;
        // Find some text in the document.
        /* method findText has missing type findtext */
        // On Windows, will draw the document into a display context such as a printer.
        /* method formatRange has missing type formatrange */
        // Retrieve the display line at the top of the display.
        attribute long firstVisibleLine;
        // Returns the number of lines in the document. There is always at least one.
        readonly attribute long lineCount;
        // Returns the size in pixels of the left margin.
        attribute long marginLeft;
        // Returns the size in pixels of the right margin.
        attribute long marginRight;
        // Is the document different from when it was last saved?
        readonly attribute boolean modify;
        // Select a range of text.
        void setSel(in long start, in long end);
        // Scroll horizontally and vertically.
        void lineScroll(in long columns, in long lines);
        // Ensure the caret is visible.
        void scrollCaret();
        // Scroll the argument positions and the range between them into view giving
        // priority to the primary position then the secondary position.
        // This may be used to make a search match visible.
        void scrollRange(in long secondary, in long primary);
        // Null operation.
        void null();
        // Will a paste succeed?
        boolean canPaste();
        // Are there any undoable actions in the undo history?
        boolean canUndo();
        // Delete the undo history.
        void emptyUndoBuffer();
        // Cut the selection to the clipboard.
        void cut();
        // Copy the selection to the clipboard.
        void copy();
        // Paste the contents of the clipboard into the document replacing the selection.
        void paste();
        // Clear the selection.
        void clear();
        // Retrieve the number of characters in the document.
        readonly attribute long textLength;
        // Retrieve a pointer to a function that processes messages for this Scintilla.
        readonly attribute ACString directFunction;
        // Retrieve a pointer value to use as the first argument when calling
        // the function returned by GetDirectFunction.
        readonly attribute ACString directPointer;
        // Returns true if overtype mode is active otherwise false is returned.
        attribute boolean overtype;
        // Returns the width of the insert mode caret.
        attribute long caretWidth;
        // Get the position that starts the target.
        attribute long targetStart;
        // Get the position that ends the target.
        attribute long targetEnd;
        // Replace the target text with the argument text.
        // Text is counted so it can contain NULs.
        // Returns the length of the replacement text.
        long replaceTarget(in nsIVariant text_or_length, [optional] in AUTF8String text_deprecated);
        // Replace the target text with the argument text after \d processing.
        // Text is counted so it can contain NULs.
        // Looks for \d where d is between 1 and 9 and replaces these with the strings
        // matched in the last search operation which were surrounded by \( and \).
        // Returns the length of the replacement text including any change
        // caused by processing the \d patterns.
        long replaceTargetRE(in nsIVariant text_or_length, [optional] in AUTF8String text_deprecated);
        // Search for a counted string in the target and set the target to the found
        // range. Text is counted so it can contain NULs.
        // Returns length of range or -1 for failure in which case target is not moved.
        long searchInTarget(in nsIVariant text_or_length, [optional] in AUTF8String text_deprecated);
        // Get the search flags used by SearchInTarget.
        attribute long searchFlags;
        // Show a call tip containing a definition near position pos.
        void callTipShow(in long pos, in AUTF8String definition);
        // Remove the call tip from the screen.
        void callTipCancel();
        // Is there an active call tip?
        boolean callTipActive();
        // Retrieve the position where the caret was before displaying the call tip.
        long callTipPosStart();
        // Highlight a segment of the definition.
        void callTipSetHlt(in long start, in long end);
        // Set the background colour for the call tip.
        void callTipSetBack(in long back);
        // Set the foreground colour for the call tip.
        void callTipSetFore(in long fore);
        // Set the foreground colour for the highlighted part of the call tip.
        void callTipSetForeHlt(in long fore);
        // Enable use of STYLE_CALLTIP and set call tip tab size in pixels.
        void callTipUseStyle(in long tabSize);
        // Set position of calltip, above or below text.
        void callTipSetPosition(in boolean above);
        // Find the display line of a document line taking hidden lines into account.
        long visibleFromDocLine(in long line);
        // Find the document line of a display line taking hidden lines into account.
        long docLineFromVisible(in long lineDisplay);
        // The number of display lines needed to wrap a document line
        long wrapCount(in long line);
        // Set the fold level of a line.
        // This encodes an integer level along with flags indicating whether the
        // line is a header and whether it is effectively white space.
        void setFoldLevel(in long line, in long level);
        // Retrieve the fold level of a line.
        long getFoldLevel(in long line);
        // Find the last child line of a header line.
        long getLastChild(in long line, in long level);
        // Find the parent line of a child line.
        long getFoldParent(in long line);
        // Make a range of lines visible.
        void showLines(in long lineStart, in long lineEnd);
        // Make a range of lines invisible.
        void hideLines(in long lineStart, in long lineEnd);
        // Is a line visible?
        boolean getLineVisible(in long line);
        // Are all lines visible?
        readonly attribute boolean allLinesVisible;
        // Show the children of a header line.
        void setFoldExpanded(in long line, in boolean expanded);
        // Is a header line expanded?
        boolean getFoldExpanded(in long line);
        // Switch a header line between expanded and contracted.
        void toggleFold(in long line);
        // Expand or contract a fold header.
        void foldLine(in long line, in long action);
        // Expand or contract a fold header and its children.
        void foldChildren(in long line, in long action);
        // Expand a fold header and all children. Use the level argument instead of the line's current level.
        void expandChildren(in long line, in long level);
        // Expand or contract all fold headers.
        void foldAll(in long action);
        // Ensure a particular line is visible by expanding any header line hiding it.
        void ensureVisible(in long line);
        // Get automatic folding behaviours.
        attribute long automaticFold;
        // Set some style options for folding.
        void setFoldFlags(in long flags);
        // Ensure a particular line is visible by expanding any header line hiding it.
        // Use the currently set visibility policy to determine which range to display.
        void ensureVisibleEnforcePolicy(in long line);
        // Does a tab pressed when caret is within indentation indent?
        attribute boolean tabIndents;
        // Does a backspace pressed when caret is within indentation unindent?
        attribute boolean backSpaceUnIndents;
        // Retrieve the time the mouse must sit still to generate a mouse dwell event.
        attribute long mouseDwellTime;
        // Get position of start of word.
        long wordStartPosition(in long pos, in boolean onlyWordCharacters);
        // Get position of end of word.
        long wordEndPosition(in long pos, in boolean onlyWordCharacters);
        // Retrieve whether text is word wrapped.
        attribute long wrapMode;
        // Retrive the display mode of visual flags for wrapped lines.
        attribute long wrapVisualFlags;
        // Retrive the location of visual flags for wrapped lines.
        attribute long wrapVisualFlagsLocation;
        // Retrive the start indent for wrapped lines.
        attribute long wrapStartIndent;
        // Retrieve how wrapped sublines are placed. Default is fixed.
        attribute long wrapIndentMode;
        // Retrieve the degree of caching of layout information.
        attribute long layoutCache;
        // Retrieve whether the scroll width tracks wide lines.
        attribute boolean scrollWidthTracking;
        // Measure the pixel width of some text in a particular style.
        // NUL terminated text argument.
        // Does not handle tab or control characters.
        long textWidth(in long style, in AUTF8String text);
        // Retrieve whether the maximum scroll position has the last
        // line at the bottom of the view.
        attribute boolean endAtLastLine;
        // Is the vertical scroll bar visible?
        attribute boolean vScrollBar;
        // Append a string to the end of the document without changing the selection.
        void appendText(in nsIVariant text_or_length, [optional] in AUTF8String text_deprecated);
        // Is drawing done in two phases with backgrounds drawn before faoregrounds?
        attribute boolean twoPhaseDraw;
        // Retrieve the quality level for text.
        attribute long fontQuality;
        // Retrieve the effect of pasting when there are multiple selections..
        attribute long multiPaste;
        // Retrieve the value of a tag from a regular expression search.
        long getTag(in long tagNumber, out AString tagValue);
        // Make the target range start and end be the same as the selection range start and end.
        void targetFromSelection();
        // Join the lines in the target.
        void linesJoin();
        // Split the lines in the target into lines that are less wide than pixelWidth
        // where possible.
        void linesSplit(in long pixelWidth);
        // Set the colours used as a chequerboard pattern in the fold margin
        void setFoldMarginColour(in boolean useSetting, in long back);
        // Set the colours used as a chequerboard pattern in the fold margin
        void setFoldMarginHiColour(in boolean useSetting, in long fore);
        // Move caret down one line.
        void lineDown();
        // Move caret down one line extending selection to new caret position.
        void lineDownExtend();
        // Move caret up one line.
        void lineUp();
        // Move caret up one line extending selection to new caret position.
        void lineUpExtend();
        // Move caret left one character.
        void charLeft();
        // Move caret left one character extending selection to new caret position.
        void charLeftExtend();
        // Move caret right one character.
        void charRight();
        // Move caret right one character extending selection to new caret position.
        void charRightExtend();
        // Move caret left one word.
        void wordLeft();
        // Move caret left one word extending selection to new caret position.
        void wordLeftExtend();
        // Move caret right one word.
        void wordRight();
        // Move caret right one word extending selection to new caret position.
        void wordRightExtend();
        // Move caret to first position on line.
        void home();
        // Move caret to first position on line extending selection to new caret position.
        void homeExtend();
        // Move caret to last position on line.
        void lineEnd();
        // Move caret to last position on line extending selection to new caret position.
        void lineEndExtend();
        // Move caret to first position in document.
        void documentStart();
        // Move caret to first position in document extending selection to new caret position.
        void documentStartExtend();
        // Move caret to last position in document.
        void documentEnd();
        // Move caret to last position in document extending selection to new caret position.
        void documentEndExtend();
        // Move caret one page up.
        void pageUp();
        // Move caret one page up extending selection to new caret position.
        void pageUpExtend();
        // Move caret one page down.
        void pageDown();
        // Move caret one page down extending selection to new caret position.
        void pageDownExtend();
        // Switch from insert to overtype mode or the reverse.
        void editToggleOvertype();
        // Cancel any modes such as call tip or auto-completion list display.
        void cancel();
        // If selection is empty or all on one line replace the selection with a tab character.
        // If more than one line selected, indent the lines.
        void tab();
        // Dedent the selected lines.
        void backTab();
        // Insert a Form Feed character.
        void formFeed();
        // Move caret to before first visible character on line.
        // If already there move to first character on line.
        void vCHome();
        // Like VCHome but extending selection to new caret position.
        void vCHomeExtend();
        // Magnify the displayed text by increasing the sizes by 1 point.
        void zoomIn();
        // Make the displayed text smaller by decreasing the sizes by 1 point.
        void zoomOut();
};
[scriptable, uuid(52a719ee-a335-4da8-8b83-d83b38257239)]
interface ISciMoz_Part2 : nsISupports {
        // Delete the word to the left of the caret.
        void delWordLeft();
        // Delete the word to the right of the caret.
        void delWordRight();
        // Delete the word to the right of the caret, but not the trailing non-word characters.
        void delWordRightEnd();
        // Cut the line containing the caret.
        void lineCut();
        // Delete the line containing the caret.
        void lineDelete();
        // Switch the current line with the previous.
        void lineTranspose();
        // Duplicate the current line.
        void lineDuplicate();
        // Transform the selection to lower case.
        void lowerCase();
        // Transform the selection to upper case.
        void upperCase();
        // Scroll the document down, keeping the caret visible.
        void lineScrollDown();
        // Scroll the document up, keeping the caret visible.
        void lineScrollUp();
        // Delete the selection or if no selection, the character before the caret.
        // Will not delete the character before at the start of a line.
        void deleteBackNotLine();
        // Move caret to first position on display line.
        void homeDisplay();
        // Move caret to first position on display line extending selection to
        // new caret position.
        void homeDisplayExtend();
        // Move caret to last position on display line.
        void lineEndDisplay();
        // Move caret to last position on display line extending selection to new
        // caret position.
        void lineEndDisplayExtend();
        // These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
        // except they behave differently when word-wrap is enabled:
        // They go first to the start / end of the display line, like (Home|LineEnd)Display
        // The difference is that, the cursor is already at the point, it goes on to the start
        // or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
        void homeWrap();
        // These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
        // except they behave differently when word-wrap is enabled:
        // They go first to the start / end of the display line, like (Home|LineEnd)Display
        // The difference is that, the cursor is already at the point, it goes on to the start
        // or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
        void homeWrapExtend();
        // These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
        // except they behave differently when word-wrap is enabled:
        // They go first to the start / end of the display line, like (Home|LineEnd)Display
        // The difference is that, the cursor is already at the point, it goes on to the start
        // or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
        void lineEndWrap();
        // These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
        // except they behave differently when word-wrap is enabled:
        // They go first to the start / end of the display line, like (Home|LineEnd)Display
        // The difference is that, the cursor is already at the point, it goes on to the start
        // or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
        void lineEndWrapExtend();
        // These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
        // except they behave differently when word-wrap is enabled:
        // They go first to the start / end of the display line, like (Home|LineEnd)Display
        // The difference is that, the cursor is already at the point, it goes on to the start
        // or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
        void vCHomeWrap();
        // These are like their namesakes Home(Extend)?, LineEnd(Extend)?, VCHome(Extend)?
        // except they behave differently when word-wrap is enabled:
        // They go first to the start / end of the display line, like (Home|LineEnd)Display
        // The difference is that, the cursor is already at the point, it goes on to the start
        // or end of the document line, as appropriate for (Home|LineEnd|VCHome)(Extend)?.
        void vCHomeWrapExtend();
        // Copy the line containing the caret.
        void lineCopy();
        // Move the caret inside current view if it's not there already.
        void moveCaretInsideView();
        // How many characters are on a line, including end of line characters?
        long lineLength(in long line);
        // Highlight the characters at two positions.
        void braceHighlight(in long pos1, in long pos2);
        // Use specified indicator to highlight matching braces instead of changing their style.
        void braceHighlightIndicator(in boolean useBraceHighlightIndicator, in long indicator);
        // Highlight the character at a position indicating there is no matching brace.
        void braceBadLight(in long pos);
        // Use specified indicator to highlight non matching brace instead of changing its style.
        void braceBadLightIndicator(in boolean useBraceBadLightIndicator, in long indicator);
        // Find the position of a matching brace or INVALID_POSITION if no match.
        long braceMatch(in long pos);
        // Are the end of line characters visible?
        attribute boolean viewEOL;
        // Retrieve a pointer to the document object.
        attribute ACString docPointer;
        // Retrieve the column number which text should be kept within.
        attribute long edgeColumn;
        // Retrieve the edge highlight mode.
        attribute long edgeMode;
        // Retrieve the colour used in edge indication.
        attribute long edgeColour;
        // Sets the current caret position to be the search anchor.
        void searchAnchor();
        // Find some text starting at the search anchor.
        // Does not ensure the selection is visible.
        long searchNext(in long flags, in AUTF8String text);
        // Find some text starting at the search anchor and moving backwards.
        // Does not ensure the selection is visible.
        long searchPrev(in long flags, in AUTF8String text);
        // Retrieves the number of lines completely visible.
        readonly attribute long linesOnScreen;
        // Set whether a pop up menu is displayed automatically when the user presses
        // the wrong mouse button.
        void usePopUp(in boolean allowPopUp);
        // Is the selection rectangular? The alternative is the more common stream selection.
        readonly attribute boolean selectionIsRectangle;
        // Retrieve the zoom level.
        attribute long zoom;
        // Create a new document object.
        // Starts with reference count of 1 and not selected into editor.
        ACString createDocument();
        // Extend life of document.
        void addRefDocument(in ACString doc);
        // Release a reference to the document, deleting document if it fades to black.
        void releaseDocument(in ACString doc);
        // Get which document modification events are sent to the container.
        attribute long modEventMask;
        // Get internal focus flag.
        attribute boolean focus;
        // Get error status.
        attribute long status;
        // Get whether mouse gets captured.
        attribute boolean mouseDownCaptures;
        // Get cursor type.
        attribute long cursor;
        // Get the way control characters are displayed.
        attribute long controlCharSymbol;
        // Move to the previous change in capitalisation.
        void wordPartLeft();
        // Move to the previous change in capitalisation extending selection
        // to new caret position.
        void wordPartLeftExtend();
        // Move to the change next in capitalisation.
        void wordPartRight();
        // Move to the next change in capitalisation extending selection
        // to new caret position.
        void wordPartRightExtend();
        // Set the way the display area is determined when a particular line
        // is to be moved to by Find, FindNext, GotoLine, etc.
        void setVisiblePolicy(in long visiblePolicy, in long visibleSlop);
        // Delete back from the current position to the start of the line.
        void delLineLeft();
        // Delete forwards from the current position to the end of the line.
        void delLineRight();
        // Set the last x chosen value to be the caret x position.
        void chooseCaretX();
        // Set the focus to this Scintilla widget.
        void grabFocus();
        // Set the way the caret is kept visible when going sideways.
        // The exclusion zone is given in pixels.
        void setXCaretPolicy(in long caretPolicy, in long caretSlop);
        // Set the way the line the caret is on is kept visible.
        // The exclusion zone is given in lines.
        void setYCaretPolicy(in long caretPolicy, in long caretSlop);
        // Is printing line wrapped?
        attribute long printWrapMode;
        // Set a fore colour for active hotspots.
        void setHotspotActiveFore(in boolean useSetting, in long fore);
        // Get the fore colour for active hotspots.
        long getHotspotActiveFore();
        // Set a back colour for active hotspots.
        void setHotspotActiveBack(in boolean useSetting, in long back);
        // Get the back colour for active hotspots.
        long getHotspotActiveBack();
        // Enable / Disable underlining active hotspots.
        void setHotspotActiveUnderline(in boolean underline);
        // Get whether underlining for active hotspots.
        boolean getHotspotActiveUnderline();
        // Get the HotspotSingleLine property
        attribute boolean hotspotSingleLine;
        // Move caret between paragraphs (delimited by empty lines).
        void paraDown();
        // Move caret between paragraphs (delimited by empty lines).
        void paraDownExtend();
        // Move caret between paragraphs (delimited by empty lines).
        void paraUp();
        // Move caret between paragraphs (delimited by empty lines).
        void paraUpExtend();
        // Given a valid document position, return the previous position taking code
        // page into account. Returns 0 if passed 0.
        long positionBefore(in long pos);
        // Copy a range of text to the clipboard. Positions are clipped into the document.
        void copyRange(in long start, in long end);
        // Copy argument text to the clipboard.
        void copyText(in long length, in AUTF8String text);
        // Get the mode of the current selection.
        attribute long selectionMode;
        // Retrieve the position of the start of the selection at the given line (INVALID_POSITION if no selection on this line).
        long getLineSelStartPosition(in long line);
        // Retrieve the position of the end of the selection at the given line (INVALID_POSITION if no selection on this line).
        long getLineSelEndPosition(in long line);
        // Move caret down one line, extending rectangular selection to new caret position.
        void lineDownRectExtend();
        // Move caret up one line, extending rectangular selection to new caret position.
        void lineUpRectExtend();
        // Move caret left one character, extending rectangular selection to new caret position.
        void charLeftRectExtend();
        // Move caret right one character, extending rectangular selection to new caret position.
        void charRightRectExtend();
        // Move caret to first position on line, extending rectangular selection to new caret position.
        void homeRectExtend();
        // Move caret to before first visible character on line.
        // If already there move to first character on line.
        // In either case, extend rectangular selection to new caret position.
        void vCHomeRectExtend();
        // Move caret to last position on line, extending rectangular selection to new caret position.
        void lineEndRectExtend();
        // Move caret one page up, extending rectangular selection to new caret position.
        void pageUpRectExtend();
        // Move caret one page down, extending rectangular selection to new caret position.
        void pageDownRectExtend();
        // Move caret to top of page, or one page up if already at top of page.
        void stutteredPageUp();
        // Move caret to top of page, or one page up if already at top of page, extending selection to new caret position.
        void stutteredPageUpExtend();
        // Move caret to bottom of page, or one page down if already at bottom of page.
        void stutteredPageDown();
        // Move caret to bottom of page, or one page down if already at bottom of page, extending selection to new caret position.
        void stutteredPageDownExtend();
        // Move caret left one word, position cursor at end of word.
        void wordLeftEnd();
        // Move caret left one word, position cursor at end of word, extending selection to new caret position.
        void wordLeftEndExtend();
        // Move caret right one word, position cursor at end of word.
        void wordRightEnd();
        // Move caret right one word, position cursor at end of word, extending selection to new caret position.
        void wordRightEndExtend();
        // Set the set of characters making up whitespace for when moving or selecting by word.
        // Should be called after SetWordChars.
        void setWhitespaceChars(in AUTF8String characters);
        // Get the set of characters making up whitespace for when moving or selecting by word.
        long getWhitespaceChars(out AString characters);
        // Set the set of characters making up punctuation characters
        // Should be called after SetWordChars.
        void setPunctuationChars(in AUTF8String characters);
        // Get the set of characters making up punctuation characters
        long getPunctuationChars(out AString characters);
        // Reset the set of characters for whitespace and word characters to the defaults.
        void setCharsDefault();
        // Get currently selected item position in the auto-completion list
        readonly attribute long autoCCurrent;
        // Get currently selected item text in the auto-completion list
        // Returns the length of the item text
        long autoCGetCurrentText(out AString s);
        // Get auto-completion case insensitive behaviour.
        attribute long autoCCaseInsensitiveBehaviour;
        // Get the way autocompletion lists are ordered.
        attribute long autoCOrder;
        // Enlarge the document to a particular size of text bytes.
        void allocate(in long bytes);
        // Returns the target converted to UTF8.
        // Return the length in bytes.
        long targetAsUTF8(out AString s);
        // Set the length of the utf8 argument for calling EncodedFromUTF8.
        // Set to -1 and the string will be measured to the first nul.
        void setLengthForEncode(in long bytes);
        // Translates a UTF8 string into the document encoding.
        // Return the length of the result in bytes.
        // On error return 0.
        long encodedFromUTF8(in AUTF8String utf8, out AString encoded);
        // Find the position of a column on a line taking into account tabs and
        // multi-byte characters. If beyond end of line, return line end position.
        long findColumn(in long line, in long column);
        // Can the caret preferred x position only be changed by explicit movement commands?
        attribute long caretSticky;
        // Switch between sticky and non-sticky: meant to be bound to a key.
        void toggleCaretSticky();
        // Get convert-on-paste setting
        attribute boolean pasteConvertEndings;
        // Duplicate the selection. If selection empty duplicate the line containing the caret.
        void selectionDuplicate();
        // Get the background alpha of the caret line.
        attribute long caretLineBackAlpha;
        // Stop all Scintilla timers (caret, dwell, ...).
        void stopTimers();
        // Returns the current style of the caret.
        attribute long caretStyle;
        // Get the current indicator
        attribute long indicatorCurrent;
        // Get the current indicator value
        attribute long indicatorValue;
        // Turn a indicator on over a range.
        void indicatorFillRange(in long position, in long fillLength);
        // Turn a indicator off over a range.
        void indicatorClearRange(in long position, in long clearLength);
        // Are any indicators present at position?
        long indicatorAllOnFor(in long position);
        // What value does a particular indicator have at at a position?
        long indicatorValueAt(in long indicator, in long position);
        // Where does a particular indicator start?
        long indicatorStart(in long indicator, in long position);
        // Where does a particular indicator end?
        long indicatorEnd(in long indicator, in long position);
        // How many entries are allocated to the position cache?
        attribute long positionCache;
};
[scriptable, uuid(70c2de0f-2935-481b-a034-9d4426d5f77c)]
interface ISciMoz_Part3 : nsISupports {
        // Copy the selection, if selection empty copy the line with the caret
        void copyAllowLine();
        // Compact the document buffer and return a read-only pointer to the
        // characters in the document.
        readonly attribute long characterPointer;
        // Return a read-only pointer to a range of characters in the document.
        // May move the gap so that the range is contiguous, but will only move up
        // to rangeLength bytes.
        long getRangePointer(in long position, in long rangeLength);
        // Return a position which, to avoid performance costs, should not be within
        // the range of a call to GetRangePointer.
        readonly attribute long gapPosition;
        // Are keys always interpreted as Unicode?
        attribute boolean keysUnicode;
        // Set the alpha fill colour of the given indicator.
        void indicSetAlpha(in long indicator, in long alpha);
        // Get the alpha fill colour of the given indicator.
        long indicGetAlpha(in long indicator);
        // Set the alpha outline colour of the given indicator.
        void indicSetOutlineAlpha(in long indicator, in long alpha);
        // Get the alpha outline colour of the given indicator.
        long indicGetOutlineAlpha(in long indicator);
        // Get extra ascent for each line
        attribute long extraAscent;
        // Get extra descent for each line
        attribute long extraDescent;
        // Which symbol was defined for markerNumber with MarkerDefine
        long markerSymbolDefined(in long markerNumber);
        // Set the text in the text margin for a line
        void marginSetText(in long line, in AUTF8String text);
        // Get the text in the text margin for a line
        long marginGetText(in long line, out AString text);
        // Set the style number for the text margin for a line
        void marginSetStyle(in long line, in long style);
        // Get the style number for the text margin for a line
        long marginGetStyle(in long line);
        // Set the style in the text margin for a line
        void marginSetStyles(in long line, in AUTF8String styles);
        // Get the styles in the text margin for a line
        long marginGetStyles(in long line, out AString styles);
        // Clear the margin text on all lines
        void marginTextClearAll();
        // Get the start of the range of style numbers used for margin text
        attribute long marginStyleOffset;
        // Get the margin options.
        attribute long marginOptions;
        // Set the annotation text for a line
        void annotationSetText(in long line, in AUTF8String text);
        // Get the annotation text for a line
        long annotationGetText(in long line, out AString text);
        // Set the style number for the annotations for a line
        void annotationSetStyle(in long line, in long style);
        // Get the style number for the annotations for a line
        long annotationGetStyle(in long line);
        // Set the annotation styles for a line
        void annotationSetStyles(in long line, in AUTF8String styles);
        // Get the annotation styles for a line
        long annotationGetStyles(in long line, out AString styles);
        // Get the number of annotation lines for a line
        long annotationGetLines(in long line);
        // Clear the annotations from all lines
        void annotationClearAll();
        // Get the visibility for the annotations for a view
        attribute long annotationVisible;
        // Get the start of the range of style numbers used for annotations
        attribute long annotationStyleOffset;
        // Release all extended (>255) style numbers
        void releaseAllExtendedStyles();
        // Allocate some extended (>255) style numbers and return the start of the range
        long allocateExtendedStyles(in long numberStyles);
        // Add a container action to the undo stack
        void addUndoAction(in long token, in long flags);
        // Find the position of a character from a point within the window.
        long charPositionFromPoint(in long x, in long y);
        // Whether multiple selections can be made
        attribute boolean multipleSelection;
        // Whether typing can be performed into multiple selections
        attribute boolean additionalSelectionTyping;
        // Whether additional carets will blink
        attribute boolean additionalCaretsBlink;
        // Whether additional carets are visible
        attribute boolean additionalCaretsVisible;
        // How many selections are there?
        readonly attribute long selections;
        // Is every selected range empty?
        readonly attribute boolean selectionEmpty;
        // Clear selections to a single empty stream selection
        void clearSelections();
        // Set a simple selection
        long setSelection(in long caret, in long anchor);
        // Add a selection
        long addSelection(in long caret, in long anchor);
        // Which selection is the main selection
        attribute long mainSelection;
        // Which selection is the main selection
        void setSelectionNCaret(in long selection, in long pos);
        // Which selection is the main selection
        long getSelectionNCaret(in long selection);
        // Which selection is the main selection
        void setSelectionNAnchor(in long selection, in long posAnchor);
        // Which selection is the main selection
        long getSelectionNAnchor(in long selection);
        // Which selection is the main selection
        void setSelectionNCaretVirtualSpace(in long selection, in long space);
        // Which selection is the main selection
        long getSelectionNCaretVirtualSpace(in long selection);
        // Which selection is the main selection
        void setSelectionNAnchorVirtualSpace(in long selection, in long space);
        // Which selection is the main selection
        long getSelectionNAnchorVirtualSpace(in long selection);
        // Sets the position that starts the selection - this becomes the anchor.
        void setSelectionNStart(in long selection, in long pos);
        // Returns the position at the start of the selection.
        long getSelectionNStart(in long selection);
        // Sets the position that ends the selection - this becomes the currentPosition.
        void setSelectionNEnd(in long selection, in long pos);
        // Returns the position at the end of the selection.
        long getSelectionNEnd(in long selection);
        // Returns the position at the end of the selection.
        attribute long rectangularSelectionCaret;
        // Returns the position at the end of the selection.
        attribute long rectangularSelectionAnchor;
        // Returns the position at the end of the selection.
        attribute long rectangularSelectionCaretVirtualSpace;
        // Returns the position at the end of the selection.
        attribute long rectangularSelectionAnchorVirtualSpace;
        // Returns the position at the end of the selection.
        attribute long virtualSpaceOptions;
        // Get the modifier key used for rectangular selection.
        attribute long rectangularSelectionModifier;
        // Set the foreground colour of additional selections.
        // Must have previously called SetSelFore with non-zero first argument for this to have an effect.
        void setAdditionalSelFore(in long fore);
        // Set the background colour of additional selections.
        // Must have previously called SetSelBack with non-zero first argument for this to have an effect.
        void setAdditionalSelBack(in long back);
        // Get the alpha of the selection.
        attribute long additionalSelAlpha;
        // Get the foreground colour of additional carets.
        attribute long additionalCaretFore;
        // Set the main selection to the next selection.
        void rotateSelection();
        // Swap that caret and anchor of the main selection.
        void swapMainAnchorCaret();
        // Indicate that the internal state of a lexer has changed over a range and therefore
        // there may be a need to redraw.
        long changeLexerState(in long start, in long end);
        // Find the next line at or after lineStart that is a contracted fold header line.
        // Return -1 when no more lines.
        long contractedFoldNext(in long lineStart);
        // Centre current line in window.
        void verticalCentreCaret();
        // Move the selected lines up one line, shifting the line above after the selection
        void moveSelectedLinesUp();
        // Move the selected lines down one line, shifting the line below before the selection
        void moveSelectedLinesDown();
        // Get the identifier.
        attribute long identifier;
        // Set the width for future RGBA image data.
        void rGBAImageSetWidth(in long width);
        // Set the height for future RGBA image data.
        void rGBAImageSetHeight(in long height);
        // Set the scale factor in percent for future RGBA image data.
        void rGBAImageSetScale(in long scalePercent);
        // Define a marker from RGBA data.
        // It has the width and height from RGBAImageSetWidth/Height
        void markerDefineRGBAImage(in long markerNumber, in AUTF8String pixels);
        // Register an RGBA image for use in autocompletion lists.
        // It has the width and height from RGBAImageSetWidth/Height
        void registerRGBAImage(in long type, in AUTF8String pixels);
        // Scroll to start of document.
        void scrollToStart();
        // Scroll to end of document.
        void scrollToEnd();
        // Get the tech.
        attribute long technology;
        // Create an ILoader*.
        long createLoader(in long bytes);
        // On OS X, show a find indicator.
        void findIndicatorShow(in long start, in long end);
        // On OS X, flash a find indicator, then fade out.
        void findIndicatorFlash(in long start, in long end);
        // On OS X, hide the find indicator.
        void findIndicatorHide();
        // Move caret to before first visible character on display line.
        // If already there move to first character on display line.
        void vCHomeDisplay();
        // Like VCHomeDisplay but extending selection to new caret position.
        void vCHomeDisplayExtend();
        // Is the caret line always visible?
        attribute boolean caretLineVisibleAlways;
        // Start notifying the container of all key presses and commands.
        void startRecord();
        // Stop notifying the container of all key presses and commands.
        void stopRecord();
        // Retrieve the lexing language of the document.
        attribute long lexer;
        // Colourise a segment of the document using the current lexing language.
        void colourise(in long start, in long end);
        // Set up a value that may be used by a lexer for some optional feature.
        void setProperty(in AUTF8String key, in AUTF8String value);
        // Set up the key words used by the lexer.
        void setKeyWords(in long keywordSet, in AUTF8String keyWords);
        // Set the lexing language of the document based on string name.
        void setLexerLanguage(in AUTF8String language);
        // Load a lexer library (dll / so).
        void loadLexerLibrary(in AUTF8String path);
        // Retrieve a "property" value previously set with SetProperty.
        long getProperty(in AUTF8String key, out AString buf);
        // Retrieve a "property" value previously set with SetProperty,
        // with "$()" variable replacement on returned buffer.
        long getPropertyExpanded(in AUTF8String key, out AString buf);
        // Retrieve a "property" value previously set with SetProperty,
        // interpreted as an int AFTER any "$()" variable replacement.
        long getPropertyInt(in AUTF8String key);
        // Retrieve the number of bits the current lexer needs for styling.
        readonly attribute long styleBitsNeeded;
        // Retrieve the name of the lexer.
        // Return the length of the text.
        long getLexerLanguage(out AString text);
        // Returns the position of the caret.
        attribute long dragPosition;
        // Returns the position of the column.
        long positionAtColumn(in long line, in long column);
        // Temporarily stop mouse tracking - until the next mouse button event.
        void releaseMouseCapture();
        // Returns whether the editor is not claiming selections
        attribute boolean rejectSelectionClaim;
        // Tell the editor the current scintilla object is a minimap
        attribute boolean suppressDragDrop;
        // Tell the editor about the editEnableMouseZoom pref
        attribute boolean suppressZoomOnScrollWheel;
        // For private communication between an application and a known lexer.
        long privateLexerCall(in long operation, in long pointer);
        // Retrieve a '\n' separated list of properties understood by the current lexer.
        long propertyNames(out AString names);
        // Retrieve the type of a property.
        long propertyType(in AUTF8String name);
        // Describe a property.
        long describeProperty(in AUTF8String name, out AString description);
        // Retrieve a '\n' separated list of descriptions of the keyword sets understood by the current lexer.
        long describeKeyWordSets(out AString descriptions);
        // Get the line end types currently allowed.
        attribute long lineEndTypesAllowed;
        // Get the line end types currently recognised. May be a subset of the allowed types due to lexer limitation.
        readonly attribute long lineEndTypesActive;
        // Bit set of LineEndType enumertion for which line ends beyond the standard
        // LF, CR, and CRLF are supported by the lexer.
        readonly attribute long lineEndTypesSupported;
        // Allocate a set of sub styles for a particular base style, returning start of range
        long allocateSubStyles(in long styleBase, in long numberStyles);
        // The starting style number for the sub styles associated with a base style
        long getSubStylesStart(in long styleBase);
        // The number of sub styles associated with a base style
        long getSubStylesLength(in long styleBase);
        // Free allocated sub styles
        void freeSubStyles();
        // Set the identifiers that are shown in a particular style
        void setIdentifiers(in long style, in AUTF8String identifiers);
};
[scriptable, uuid(2d6994c8-f637-438b-82dc-89ffbe0d42b8)]
interface ISciMoz_Part4 : nsISupports {
        // Where styles are duplicated by a feature such as active/inactive code
        // return the distance between the two types.
        readonly attribute long distanceToSecondaryStyles;
        // Get the set of base styles that can be extended with sub styles
        long getSubStyleBases(out AString styles);
        // Deprecated in 2.30
        // In palette mode?
        attribute boolean usePalette;
};


// END GENERATED SECTION.
//--Autogenerated

[scriptable, uuid(1ef5ac2f-6b7b-4266-a214-cf9875f4184e)]
interface ISciMoz : ISciMozLite {
	// Manually created features go in the "lite" version - hopefully
	// will never be 128 total there!

	// Other functions required due to our special event processing.
	void buttonDown(in long x,
			in long y,
			in uint16_t button,
			in boolean bShift,
			in boolean bCtrl,
			in boolean bAlt);
	void buttonUp(in long x,
		      in long y,
		      in uint16_t button,
		      in boolean bShift,
		      in boolean bCtrl,
		      in boolean bAlt);
	void buttonMove(in long x, in long y);

	// constants go here, because they don't take up any space in the xpt
	// stub it's safe to have them all (and makes it easier to find the
	// constants)
        const long INVALID_POSITION = -1;
        const long SCWS_INVISIBLE = 0;
        const long SCWS_VISIBLEALWAYS = 1;
        const long SCWS_VISIBLEAFTERINDENT = 2;
        const long SC_EOL_CRLF = 0;
        const long SC_EOL_CR = 1;
        const long SC_EOL_LF = 2;
        const long SC_CP_UTF8 = 65001;
        const long MARKER_MAX = 31;
        const long SC_MARK_CIRCLE = 0;
        const long SC_MARK_ROUNDRECT = 1;
        const long SC_MARK_ARROW = 2;
        const long SC_MARK_SMALLRECT = 3;
        const long SC_MARK_SHORTARROW = 4;
        const long SC_MARK_EMPTY = 5;
        const long SC_MARK_ARROWDOWN = 6;
        const long SC_MARK_MINUS = 7;
        const long SC_MARK_PLUS = 8;
        const long SC_MARK_VLINE = 9;
        const long SC_MARK_LCORNER = 10;
        const long SC_MARK_TCORNER = 11;
        const long SC_MARK_BOXPLUS = 12;
        const long SC_MARK_BOXPLUSCONNECTED = 13;
        const long SC_MARK_BOXMINUS = 14;
        const long SC_MARK_BOXMINUSCONNECTED = 15;
        const long SC_MARK_LCORNERCURVE = 16;
        const long SC_MARK_TCORNERCURVE = 17;
        const long SC_MARK_CIRCLEPLUS = 18;
        const long SC_MARK_CIRCLEPLUSCONNECTED = 19;
        const long SC_MARK_CIRCLEMINUS = 20;
        const long SC_MARK_CIRCLEMINUSCONNECTED = 21;
        const long SC_MARK_BACKGROUND = 22;
        const long SC_MARK_DOTDOTDOT = 23;
        const long SC_MARK_ARROWS = 24;
        const long SC_MARK_PIXMAP = 25;
        const long SC_MARK_FULLRECT = 26;
        const long SC_MARK_LEFTRECT = 27;
        const long SC_MARK_AVAILABLE = 28;
        const long SC_MARK_UNDERLINE = 29;
        const long SC_MARK_RGBAIMAGE = 30;
        const long SC_MARK_CHARACTER = 10000;
        const long SC_MARKNUM_FOLDEREND = 25;
        const long SC_MARKNUM_FOLDEROPENMID = 26;
        const long SC_MARKNUM_FOLDERMIDTAIL = 27;
        const long SC_MARKNUM_FOLDERTAIL = 28;
        const long SC_MARKNUM_FOLDERSUB = 29;
        const long SC_MARKNUM_FOLDER = 30;
        const long SC_MARKNUM_FOLDEROPEN = 31;
        const unsigned long SC_MASK_FOLDERS = 0xFE000000;
        const long SC_MAX_MARGIN = 4;
        const long SC_MARGIN_SYMBOL = 0;
        const long SC_MARGIN_NUMBER = 1;
        const long SC_MARGIN_BACK = 2;
        const long SC_MARGIN_FORE = 3;
        const long SC_MARGIN_TEXT = 4;
        const long SC_MARGIN_RTEXT = 5;
        const long STYLE_DEFAULT = 32;
        const long STYLE_LINENUMBER = 33;
        const long STYLE_BRACELIGHT = 34;
        const long STYLE_BRACEBAD = 35;
        const long STYLE_CONTROLCHAR = 36;
        const long STYLE_INDENTGUIDE = 37;
        const long STYLE_CALLTIP = 38;
        const long STYLE_LASTPREDEFINED = 39;
        const long STYLE_MAX = 255;
        const long SC_CHARSET_ANSI = 0;
        const long SC_CHARSET_DEFAULT = 1;
        const long SC_CHARSET_BALTIC = 186;
        const long SC_CHARSET_CHINESEBIG5 = 136;
        const long SC_CHARSET_EASTEUROPE = 238;
        const long SC_CHARSET_GB2312 = 134;
        const long SC_CHARSET_GREEK = 161;
        const long SC_CHARSET_HANGUL = 129;
        const long SC_CHARSET_MAC = 77;
        const long SC_CHARSET_OEM = 255;
        const long SC_CHARSET_RUSSIAN = 204;
        const long SC_CHARSET_CYRILLIC = 1251;
        const long SC_CHARSET_SHIFTJIS = 128;
        const long SC_CHARSET_SYMBOL = 2;
        const long SC_CHARSET_TURKISH = 162;
        const long SC_CHARSET_JOHAB = 130;
        const long SC_CHARSET_HEBREW = 177;
        const long SC_CHARSET_ARABIC = 178;
        const long SC_CHARSET_VIETNAMESE = 163;
        const long SC_CHARSET_THAI = 222;
        const long SC_CHARSET_8859_15 = 1000;
        const long SC_CASE_MIXED = 0;
        const long SC_CASE_UPPER = 1;
        const long SC_CASE_LOWER = 2;
        const long SC_FONT_SIZE_MULTIPLIER = 100;
        const long SC_WEIGHT_NORMAL = 400;
        const long SC_WEIGHT_SEMIBOLD = 600;
        const long SC_WEIGHT_BOLD = 700;
        const long INDIC_PLAIN = 0;
        const long INDIC_SQUIGGLE = 1;
        const long INDIC_TT = 2;
        const long INDIC_DIAGONAL = 3;
        const long INDIC_STRIKE = 4;
        const long INDIC_HIDDEN = 5;
        const long INDIC_BOX = 6;
        const long INDIC_ROUNDBOX = 7;
        const long INDIC_STRAIGHTBOX = 8;
        const long INDIC_DASH = 9;
        const long INDIC_DOTS = 10;
        const long INDIC_SQUIGGLELOW = 11;
        const long INDIC_DOTBOX = 12;
        const long INDIC_SQUIGGLEPIXMAP = 13;
        const long INDIC_COMPOSITIONTHICK = 14;
        const long INDIC_MAX = 63;
        const long INDIC_CONTAINER = 8;
        const long INDIC0_MASK = 0x20;
        const long INDIC1_MASK = 0x40;
        const long INDIC2_MASK = 0x80;
        const long INDICS_MASK = 0xE0;
        const long SC_IV_NONE = 0;
        const long SC_IV_REAL = 1;
        const long SC_IV_LOOKFORWARD = 2;
        const long SC_IV_LOOKBOTH = 3;
        const long SC_PRINT_NORMAL = 0;
        const long SC_PRINT_INVERTLIGHT = 1;
        const long SC_PRINT_BLACKONWHITE = 2;
        const long SC_PRINT_COLOURONWHITE = 3;
        const long SC_PRINT_COLOURONWHITEDEFAULTBG = 4;
        const long SCFIND_WHOLEWORD = 2;
        const long SCFIND_MATCHCASE = 4;
        const unsigned long SCFIND_WORDSTART = 0x00100000;
        const unsigned long SCFIND_REGEXP = 0x00200000;
        const unsigned long SCFIND_POSIX = 0x00400000;
        const long SC_FOLDLEVELBASE = 0x400;
        const long SC_FOLDLEVELWHITEFLAG = 0x1000;
        const long SC_FOLDLEVELHEADERFLAG = 0x2000;
        const long SC_FOLDLEVELNUMBERMASK = 0x0FFF;
        const long SC_FOLDACTION_CONTRACT = 0;
        const long SC_FOLDACTION_EXPAND = 1;
        const long SC_FOLDACTION_TOGGLE = 2;
        const long SC_AUTOMATICFOLD_SHOW = 0x0001;
        const long SC_AUTOMATICFOLD_CLICK = 0x0002;
        const long SC_AUTOMATICFOLD_CHANGE = 0x0004;
        const long SC_FOLDFLAG_LINEBEFORE_EXPANDED = 0x0002;
        const long SC_FOLDFLAG_LINEBEFORE_CONTRACTED = 0x0004;
        const long SC_FOLDFLAG_LINEAFTER_EXPANDED = 0x0008;
        const long SC_FOLDFLAG_LINEAFTER_CONTRACTED = 0x0010;
        const long SC_FOLDFLAG_LEVELNUMBERS = 0x0040;
        const long SC_TIME_FOREVER = 10000000;
        const long SC_WRAP_NONE = 0;
        const long SC_WRAP_WORD = 1;
        const long SC_WRAP_CHAR = 2;
        const long SC_WRAPVISUALFLAG_NONE = 0x0000;
        const long SC_WRAPVISUALFLAG_END = 0x0001;
        const long SC_WRAPVISUALFLAG_START = 0x0002;
        const long SC_WRAPVISUALFLAG_MARGIN = 0x0004;
        const long SC_WRAPVISUALFLAGLOC_DEFAULT = 0x0000;
        const long SC_WRAPVISUALFLAGLOC_END_BY_TEXT = 0x0001;
        const long SC_WRAPVISUALFLAGLOC_START_BY_TEXT = 0x0002;
        const long SC_WRAPINDENT_FIXED = 0;
        const long SC_WRAPINDENT_SAME = 1;
        const long SC_WRAPINDENT_INDENT = 2;
        const long SC_CACHE_NONE = 0;
        const long SC_CACHE_CARET = 1;
        const long SC_CACHE_PAGE = 2;
        const long SC_CACHE_DOCUMENT = 3;
        const long SC_EFF_QUALITY_MASK = 0xF;
        const long SC_EFF_QUALITY_DEFAULT = 0;
        const long SC_EFF_QUALITY_NON_ANTIALIASED = 1;
        const long SC_EFF_QUALITY_ANTIALIASED = 2;
        const long SC_EFF_QUALITY_LCD_OPTIMIZED = 3;
        const long SC_MULTIPASTE_ONCE = 0;
        const long SC_MULTIPASTE_EACH = 1;
        const long EDGE_NONE = 0;
        const long EDGE_LINE = 1;
        const long EDGE_BACKGROUND = 2;
        const long SC_STATUS_OK = 0;
        const long SC_STATUS_FAILURE = 1;
        const long SC_STATUS_BADALLOC = 2;
        const long SC_CURSORNORMAL = -1;
        const long SC_CURSORARROW = 2;
        const long SC_CURSORWAIT = 4;
        const long SC_CURSORREVERSEARROW = 7;
        const long VISIBLE_SLOP = 0x01;
        const long VISIBLE_STRICT = 0x04;
        const long CARET_SLOP = 0x01;
        const long CARET_STRICT = 0x04;
        const long CARET_JUMPS = 0x10;
        const long CARET_EVEN = 0x08;
        const long SC_SEL_STREAM = 0;
        const long SC_SEL_RECTANGLE = 1;
        const long SC_SEL_LINES = 2;
        const long SC_SEL_THIN = 3;
        const long SC_CASEINSENSITIVEBEHAVIOUR_RESPECTCASE = 0;
        const long SC_CASEINSENSITIVEBEHAVIOUR_IGNORECASE = 1;
        const long SC_ORDER_PRESORTED = 0;
        const long SC_ORDER_PERFORMSORT = 1;
        const long SC_ORDER_CUSTOM = 2;
        const long SC_CARETSTICKY_OFF = 0;
        const long SC_CARETSTICKY_ON = 1;
        const long SC_CARETSTICKY_WHITESPACE = 2;
        const long SC_ALPHA_TRANSPARENT = 0;
        const long SC_ALPHA_OPAQUE = 255;
        const long SC_ALPHA_NOALPHA = 256;
        const long CARETSTYLE_INVISIBLE = 0;
        const long CARETSTYLE_LINE = 1;
        const long CARETSTYLE_BLOCK = 2;
        const long SC_MARGINOPTION_NONE = 0;
        const long SC_MARGINOPTION_SUBLINESELECT = 1;
        const long ANNOTATION_HIDDEN = 0;
        const long ANNOTATION_STANDARD = 1;
        const long ANNOTATION_BOXED = 2;
        const long UNDO_MAY_COALESCE = 1;
        const long SCVS_NONE = 0;
        const long SCVS_RECTANGULARSELECTION = 1;
        const long SCVS_USERACCESSIBLE = 2;
        const long SC_TECHNOLOGY_DEFAULT = 0;
        const long SC_TECHNOLOGY_DIRECTWRITE = 1;
        const long KEYWORDSET_MAX = 8;
        const long SC_TYPE_BOOLEAN = 0;
        const long SC_TYPE_INTEGER = 1;
        const long SC_TYPE_STRING = 2;
        const long SC_MOD_INSERTTEXT = 0x1;
        const long SC_MOD_DELETETEXT = 0x2;
        const long SC_MOD_CHANGESTYLE = 0x4;
        const long SC_MOD_CHANGEFOLD = 0x8;
        const long SC_PERFORMED_USER = 0x10;
        const long SC_PERFORMED_UNDO = 0x20;
        const long SC_PERFORMED_REDO = 0x40;
        const long SC_MULTISTEPUNDOREDO = 0x80;
        const long SC_LASTSTEPINUNDOREDO = 0x100;
        const long SC_MOD_CHANGEMARKER = 0x200;
        const long SC_MOD_BEFOREINSERT = 0x400;
        const long SC_MOD_BEFOREDELETE = 0x800;
        const long SC_MULTILINEUNDOREDO = 0x1000;
        const long SC_STARTACTION = 0x2000;
        const long SC_MOD_CHANGEINDICATOR = 0x4000;
        const long SC_MOD_CHANGELINESTATE = 0x8000;
        const long SC_MOD_CHANGEMARGIN = 0x10000;
        const long SC_MOD_CHANGEANNOTATION = 0x20000;
        const long SC_MOD_CONTAINER = 0x40000;
        const long SC_MOD_LEXERSTATE = 0x80000;
        const long SC_MODEVENTMASKALL = 0xFFFFF;
        const long SC_UPDATE_CONTENT = 0x1;
        const long SC_UPDATE_SELECTION = 0x2;
        const long SC_UPDATE_V_SCROLL = 0x4;
        const long SC_UPDATE_H_SCROLL = 0x8;
        const long SCEN_CHANGE = 768;
        const long SCEN_SETFOCUS = 512;
        const long SCEN_KILLFOCUS = 256;
        const long SCK_DOWN = 300;
        const long SCK_UP = 301;
        const long SCK_LEFT = 302;
        const long SCK_RIGHT = 303;
        const long SCK_HOME = 304;
        const long SCK_END = 305;
        const long SCK_PRIOR = 306;
        const long SCK_NEXT = 307;
        const long SCK_DELETE = 308;
        const long SCK_INSERT = 309;
        const long SCK_ESCAPE = 7;
        const long SCK_BACK = 8;
        const long SCK_TAB = 9;
        const long SCK_RETURN = 13;
        const long SCK_ADD = 310;
        const long SCK_SUBTRACT = 311;
        const long SCK_DIVIDE = 312;
        const long SCK_WIN = 313;
        const long SCK_RWIN = 314;
        const long SCK_MENU = 315;
        const long SCMOD_NORM = 0;
        const long SCMOD_SHIFT = 1;
        const long SCMOD_CTRL = 2;
        const long SCMOD_ALT = 4;
        const long SCMOD_SUPER = 8;
        const long SCMOD_META = 16;
        const long SCLEX_CONTAINER = 0;
        const long SCLEX_NULL = 1;
        const long SCLEX_PYTHON = 2;
        const long SCLEX_CPP = 3;
        const long SCLEX_HTML = 4;
        const long SCLEX_XML = 5;
        const long SCLEX_PERL = 6;
        const long SCLEX_SQL = 7;
        const long SCLEX_VB = 8;
        const long SCLEX_PROPERTIES = 9;
        const long SCLEX_ERRORLIST = 10;
        const long SCLEX_MAKEFILE = 11;
        const long SCLEX_BATCH = 12;
        const long SCLEX_XCODE = 13;
        const long SCLEX_LATEX = 14;
        const long SCLEX_LUA = 15;
        const long SCLEX_DIFF = 16;
        const long SCLEX_CONF = 17;
        const long SCLEX_PASCAL = 18;
        const long SCLEX_AVE = 19;
        const long SCLEX_ADA = 20;
        const long SCLEX_LISP = 21;
        const long SCLEX_RUBY = 22;
        const long SCLEX_EIFFEL = 23;
        const long SCLEX_EIFFELKW = 24;
        const long SCLEX_TCL = 25;
        const long SCLEX_NNCRONTAB = 26;
        const long SCLEX_BULLANT = 27;
        const long SCLEX_VBSCRIPT = 28;
        const long SCLEX_BAAN = 31;
        const long SCLEX_MATLAB = 32;
        const long SCLEX_SCRIPTOL = 33;
        const long SCLEX_ASM = 34;
        const long SCLEX_CPPNOCASE = 35;
        const long SCLEX_FORTRAN = 36;
        const long SCLEX_F77 = 37;
        const long SCLEX_CSS = 38;
        const long SCLEX_POV = 39;
        const long SCLEX_LOUT = 40;
        const long SCLEX_ESCRIPT = 41;
        const long SCLEX_PS = 42;
        const long SCLEX_NSIS = 43;
        const long SCLEX_MMIXAL = 44;
        const long SCLEX_CLW = 45;
        const long SCLEX_CLWNOCASE = 46;
        const long SCLEX_LOT = 47;
        const long SCLEX_YAML = 48;
        const long SCLEX_TEX = 49;
        const long SCLEX_METAPOST = 50;
        const long SCLEX_POWERBASIC = 51;
        const long SCLEX_FORTH = 52;
        const long SCLEX_ERLANG = 53;
        const long SCLEX_OCTAVE = 54;
        const long SCLEX_MSSQL = 55;
        const long SCLEX_VERILOG = 56;
        const long SCLEX_KIX = 57;
        const long SCLEX_GUI4CLI = 58;
        const long SCLEX_SPECMAN = 59;
        const long SCLEX_AU3 = 60;
        const long SCLEX_APDL = 61;
        const long SCLEX_BASH = 62;
        const long SCLEX_ASN1 = 63;
        const long SCLEX_VHDL = 64;
        const long SCLEX_CAML = 65;
        const long SCLEX_BLITZBASIC = 66;
        const long SCLEX_PUREBASIC = 67;
        const long SCLEX_HASKELL = 68;
        const long SCLEX_PHPSCRIPT = 69;
        const long SCLEX_TADS3 = 70;
        const long SCLEX_REBOL = 71;
        const long SCLEX_SMALLTALK = 72;
        const long SCLEX_FLAGSHIP = 73;
        const long SCLEX_CSOUND = 74;
        const long SCLEX_FREEBASIC = 75;
        const long SCLEX_INNOSETUP = 76;
        const long SCLEX_OPAL = 77;
        const long SCLEX_SPICE = 78;
        const long SCLEX_D = 79;
        const long SCLEX_CMAKE = 80;
        const long SCLEX_GAP = 81;
        const long SCLEX_PLM = 82;
        const long SCLEX_PROGRESS = 83;
        const long SCLEX_ABAQUS = 84;
        const long SCLEX_ASYMPTOTE = 85;
        const long SCLEX_R = 86;
        const long SCLEX_MAGIK = 87;
        const long SCLEX_POWERSHELL = 88;
        const long SCLEX_MYSQL = 89;
        const long SCLEX_PO = 90;
        const long SCLEX_TAL = 91;
        const long SCLEX_COBOL = 92;
        const long SCLEX_TACL = 93;
        const long SCLEX_SORCUS = 94;
        const long SCLEX_POWERPRO = 95;
        const long SCLEX_NIMROD = 96;
        const long SCLEX_SML = 97;
        const long SCLEX_MARKDOWN = 98;
        const long SCLEX_TXT2TAGS = 99;
        const long SCLEX_A68K = 100;
        const long SCLEX_MODULA = 101;
        const long SCLEX_COFFEESCRIPT = 102;
        const long SCLEX_TCMD = 103;
        const long SCLEX_AVS = 104;
        const long SCLEX_ECL = 105;
        const long SCLEX_OSCRIPT = 106;
        const long SCLEX_VISUALPROLOG = 107;
        const long SCLEX_LITERATEHASKELL = 108;
        const long SCLEX_STTXT = 109;
        const long SCLEX_XSLT = 110;
        const long SCLEX_UDL = 111;
        const long SCLEX_AUTOMATIC = 1000;
        const long SCE_P_DEFAULT = 0;
        const long SCE_P_COMMENTLINE = 1;
        const long SCE_P_NUMBER = 2;
        const long SCE_P_STRING = 3;
        const long SCE_P_CHARACTER = 4;
        const long SCE_P_WORD = 5;
        const long SCE_P_TRIPLE = 6;
        const long SCE_P_TRIPLEDOUBLE = 7;
        const long SCE_P_CLASSNAME = 8;
        const long SCE_P_DEFNAME = 9;
        const long SCE_P_OPERATOR = 10;
        const long SCE_P_IDENTIFIER = 11;
        const long SCE_P_COMMENTBLOCK = 12;
        const long SCE_P_STRINGEOL = 13;
        const long SCE_P_WORD2 = 14;
        const long SCE_P_DECORATOR = 15;
        const long SCE_P_STDIN  =  16;
        const long SCE_P_STDOUT  =  17;
        const long SCE_P_STDERR  =  18;
        const long SCE_P_UPPER_BOUND = 19;
        const long SCE_C_DEFAULT = 0;
        const long SCE_C_COMMENT = 1;
        const long SCE_C_COMMENTLINE = 2;
        const long SCE_C_COMMENTDOC = 3;
        const long SCE_C_NUMBER = 4;
        const long SCE_C_WORD = 5;
        const long SCE_C_STRING = 6;
        const long SCE_C_CHARACTER = 7;
        const long SCE_C_UUID = 8;
        const long SCE_C_PREPROCESSOR = 9;
        const long SCE_C_OPERATOR = 10;
        const long SCE_C_IDENTIFIER = 11;
        const long SCE_C_STRINGEOL = 12;
        const long SCE_C_VERBATIM = 13;
        const long SCE_C_REGEX = 14;
        const long SCE_C_COMMENTLINEDOC = 15;
        const long SCE_C_WORD2 = 16;
        const long SCE_C_COMMENTDOCKEYWORD = 17;
        const long SCE_C_COMMENTDOCKEYWORDERROR = 18;
        const long SCE_C_GLOBALCLASS = 19;
        const long SCE_C_STRINGRAW = 20;
        const long SCE_C_TRIPLEVERBATIM = 21;
        const long SCE_C_HASHQUOTEDSTRING = 22;
        const long SCE_C_PREPROCESSORCOMMENT = 23;
        const long SCE_C_PREPROCESSORCOMMENTDOC = 24;
        const long SCE_C_STDIN = 25;
        const long SCE_C_STDOUT = 26;
        const long SCE_C_STDERR = 27;
        const long SCE_D_DEFAULT = 0;
        const long SCE_D_COMMENT = 1;
        const long SCE_D_COMMENTLINE = 2;
        const long SCE_D_COMMENTDOC = 3;
        const long SCE_D_COMMENTNESTED = 4;
        const long SCE_D_NUMBER = 5;
        const long SCE_D_WORD = 6;
        const long SCE_D_WORD2 = 7;
        const long SCE_D_WORD3 = 8;
        const long SCE_D_TYPEDEF = 9;
        const long SCE_D_STRING = 10;
        const long SCE_D_STRINGEOL = 11;
        const long SCE_D_CHARACTER = 12;
        const long SCE_D_OPERATOR = 13;
        const long SCE_D_IDENTIFIER = 14;
        const long SCE_D_COMMENTLINEDOC = 15;
        const long SCE_D_COMMENTDOCKEYWORD = 16;
        const long SCE_D_COMMENTDOCKEYWORDERROR = 17;
        const long SCE_D_STRINGB = 18;
        const long SCE_D_STRINGR = 19;
        const long SCE_D_WORD5 = 20;
        const long SCE_D_WORD6 = 21;
        const long SCE_D_WORD7 = 22;
        const long SCE_TCL_DEFAULT = 0;
        const long SCE_TCL_COMMENT = 1;
        const long SCE_TCL_VARIABLE = 2;
        const long SCE_TCL_ARRAY = 3;
        const long SCE_TCL_NUMBER = 4;
        const long SCE_TCL_WORD = 5;
        const long SCE_TCL_STRING = 6;
        const long SCE_TCL_CHARACTER = 7;
        const long SCE_TCL_LITERAL = 8;
        const long SCE_TCL_IDENTIFIER = 9;
        const long SCE_TCL_OPERATOR = 10;
        const long SCE_TCL_EOL = 11;
        const long SCE_TCL_STDIN = 12;
        const long SCE_TCL_STDOUT = 13;
        const long SCE_TCL_STDERR = 14;
        const long SCE_TCL_UPPER_BOUND = 15;
        const long SCE_H_DEFAULT = 0;
        const long SCE_H_TAG = 1;
        const long SCE_H_TAGUNKNOWN = 2;
        const long SCE_H_ATTRIBUTE = 3;
        const long SCE_H_ATTRIBUTEUNKNOWN = 4;
        const long SCE_H_NUMBER = 5;
        const long SCE_H_DOUBLESTRING = 6;
        const long SCE_H_SINGLESTRING = 7;
        const long SCE_H_OTHER = 8;
        const long SCE_H_COMMENT = 9;
        const long SCE_H_ENTITY = 10;
        const long SCE_H_TAGEND = 11;
        const long SCE_H_XMLSTART = 12;
        const long SCE_H_XMLEND = 13;
        const long SCE_H_SCRIPT = 14;
        const long SCE_H_ASP = 15;
        const long SCE_H_ASPAT = 16;
        const long SCE_H_CDATA = 17;
        const long SCE_H_QUESTION = 18;
        const long SCE_H_VALUE = 19;
        const long SCE_H_XCCOMMENT = 20;
        const long SCE_H_SGML_DEFAULT = 21;
        const long SCE_H_SGML_COMMAND = 22;
        const long SCE_H_SGML_1ST_PARAM = 23;
        const long SCE_H_SGML_DOUBLESTRING = 24;
        const long SCE_H_SGML_SIMPLESTRING = 25;
        const long SCE_H_SGML_ERROR = 26;
        const long SCE_H_SGML_SPECIAL = 27;
        const long SCE_H_SGML_ENTITY = 28;
        const long SCE_H_SGML_COMMENT = 29;
        const long SCE_H_SGML_1ST_PARAM_COMMENT = 30;
        const long SCE_H_SGML_BLOCK_DEFAULT = 31;
        const long SCE_HJ_START = 40;
        const long SCE_HJ_DEFAULT = 41;
        const long SCE_HJ_COMMENT = 42;
        const long SCE_HJ_COMMENTLINE = 43;
        const long SCE_HJ_COMMENTDOC = 44;
        const long SCE_HJ_NUMBER = 45;
        const long SCE_HJ_WORD = 46;
        const long SCE_HJ_KEYWORD = 47;
        const long SCE_HJ_DOUBLESTRING = 48;
        const long SCE_HJ_SINGLESTRING = 49;
        const long SCE_HJ_SYMBOLS = 50;
        const long SCE_HJ_STRINGEOL = 51;
        const long SCE_HJ_REGEX = 52;
        const long SCE_HJA_START = 55;
        const long SCE_HJA_DEFAULT = 56;
        const long SCE_HJA_COMMENT = 57;
        const long SCE_HJA_COMMENTLINE = 58;
        const long SCE_HJA_COMMENTDOC = 59;
        const long SCE_HJA_NUMBER = 60;
        const long SCE_HJA_WORD = 61;
        const long SCE_HJA_KEYWORD = 62;
        const long SCE_HJA_DOUBLESTRING = 63;
        const long SCE_HJA_SINGLESTRING = 64;
        const long SCE_HJA_SYMBOLS = 65;
        const long SCE_HJA_STRINGEOL = 66;
        const long SCE_HJA_REGEX = 67;
        const long SCE_HB_START = 70;
        const long SCE_HB_DEFAULT = 71;
        const long SCE_HB_COMMENTLINE = 72;
        const long SCE_HB_NUMBER = 73;
        const long SCE_HB_WORD = 74;
        const long SCE_HB_STRING = 75;
        const long SCE_HB_IDENTIFIER = 76;
        const long SCE_HB_STRINGEOL = 77;
        const long SCE_HBA_START = 80;
        const long SCE_HBA_DEFAULT = 81;
        const long SCE_HBA_COMMENTLINE = 82;
        const long SCE_HBA_NUMBER = 83;
        const long SCE_HBA_WORD = 84;
        const long SCE_HBA_STRING = 85;
        const long SCE_HBA_IDENTIFIER = 86;
        const long SCE_HBA_STRINGEOL = 87;
        const long SCE_HP_START = 90;
        const long SCE_HP_DEFAULT = 91;
        const long SCE_HP_COMMENTLINE = 92;
        const long SCE_HP_NUMBER = 93;
        const long SCE_HP_STRING = 94;
        const long SCE_HP_CHARACTER = 95;
        const long SCE_HP_WORD = 96;
        const long SCE_HP_TRIPLE = 97;
        const long SCE_HP_TRIPLEDOUBLE = 98;
        const long SCE_HP_CLASSNAME = 99;
        const long SCE_HP_DEFNAME = 100;
        const long SCE_HP_OPERATOR = 101;
        const long SCE_HP_IDENTIFIER = 102;
        const long SCE_HPHP_COMPLEX_VARIABLE = 104;
        const long SCE_HPA_START = 105;
        const long SCE_HPA_DEFAULT = 106;
        const long SCE_HPA_COMMENTLINE = 107;
        const long SCE_HPA_NUMBER = 108;
        const long SCE_HPA_STRING = 109;
        const long SCE_HPA_CHARACTER = 110;
        const long SCE_HPA_WORD = 111;
        const long SCE_HPA_TRIPLE = 112;
        const long SCE_HPA_TRIPLEDOUBLE = 113;
        const long SCE_HPA_CLASSNAME = 114;
        const long SCE_HPA_DEFNAME = 115;
        const long SCE_HPA_OPERATOR = 116;
        const long SCE_HPA_IDENTIFIER = 117;
        const long SCE_HPHP_DEFAULT = 118;
        const long SCE_HPHP_HSTRING = 119;
        const long SCE_HPHP_SIMPLESTRING = 120;
        const long SCE_HPHP_WORD = 121;
        const long SCE_HPHP_NUMBER = 122;
        const long SCE_HPHP_VARIABLE = 123;
        const long SCE_HPHP_COMMENT = 124;
        const long SCE_HPHP_COMMENTLINE = 125;
        const long SCE_HPHP_HSTRING_VARIABLE = 126;
        const long SCE_HPHP_OPERATOR = 127;
        const long SCE_PL_DEFAULT = 0;
        const long SCE_PL_ERROR = 1;
        const long SCE_PL_COMMENTLINE = 2;
        const long SCE_PL_POD = 3;
        const long SCE_PL_NUMBER = 4;
        const long SCE_PL_WORD = 5;
        const long SCE_PL_STRING = 6;
        const long SCE_PL_CHARACTER = 7;
        const long SCE_PL_PUNCTUATION = 8;
        const long SCE_PL_PREPROCESSOR = 9;
        const long SCE_PL_OPERATOR = 10;
        const long SCE_PL_IDENTIFIER = 11;
        const long SCE_PL_SCALAR = 12;
        const long SCE_PL_ARRAY = 13;
        const long SCE_PL_HASH = 14;
        const long SCE_PL_SYMBOLTABLE = 15;
        const long SCE_PL_VARIABLE_INDEXER = 16;
        const long SCE_PL_REGEX = 17;
        const long SCE_PL_REGSUBST = 18;
        const long SCE_PL_LONGQUOTE = 19;
        const long SCE_PL_BACKTICKS = 20;
        const long SCE_PL_DATASECTION = 21;
        const long SCE_PL_HERE_DELIM = 22;
        const long SCE_PL_HERE_Q = 23;
        const long SCE_PL_HERE_QQ = 24;
        const long SCE_PL_HERE_QX = 25;
        const long SCE_PL_STRING_Q = 26;
        const long SCE_PL_STRING_QQ = 27;
        const long SCE_PL_STRING_QX = 28;
        const long SCE_PL_STRING_QR = 29;
        const long SCE_PL_STRING_QW = 30;
        const long SCE_PL_POD_VERB = 31;
        const long SCE_PL_SUB_PROTOTYPE = 40;
        const long SCE_PL_FORMAT_IDENT = 41;
        const long SCE_PL_FORMAT = 42;
        const long SCE_PL_SUB = 43;
        const long SCE_PL_SUB_ARGS = 44;
        const long SCE_PL_UNKNOWN_FIELD = 45;
        const long SCE_PL_STDIN = 46;
        const long SCE_PL_STDOUT = 47;
        const long SCE_PL_STDERR = 48;
        const long SCE_PL_UPPER_BOUND = 49;
        const long SCE_RB_DEFAULT = 0;
        const long SCE_RB_ERROR = 1;
        const long SCE_RB_COMMENTLINE = 2;
        const long SCE_RB_POD = 3;
        const long SCE_RB_NUMBER = 4;
        const long SCE_RB_WORD = 5;
        const long SCE_RB_STRING = 6;
        const long SCE_RB_CHARACTER = 7;
        const long SCE_RB_CLASSNAME = 8;
        const long SCE_RB_DEFNAME = 9;
        const long SCE_RB_OPERATOR = 10;
        const long SCE_RB_IDENTIFIER = 11;
        const long SCE_RB_REGEX = 12;
        const long SCE_RB_GLOBAL = 13;
        const long SCE_RB_SYMBOL = 14;
        const long SCE_RB_MODULE_NAME = 15;
        const long SCE_RB_INSTANCE_VAR = 16;
        const long SCE_RB_CLASS_VAR = 17;
        const long SCE_RB_BACKTICKS = 18;
        const long SCE_RB_DATASECTION = 19;
        const long SCE_RB_HERE_DELIM = 20;
        const long SCE_RB_HERE_Q = 21;
        const long SCE_RB_HERE_QQ = 22;
        const long SCE_RB_HERE_QX = 23;
        const long SCE_RB_STRING_Q = 24;
        const long SCE_RB_STRING_QQ = 25;
        const long SCE_RB_STRING_QX = 26;
        const long SCE_RB_STRING_QR = 27;
        const long SCE_RB_STRING_QW = 28;
        const long SCE_RB_STRING_QI = 29;
        const long SCE_RB_WORD_DEMOTED = 30;
        const long SCE_RB_STDIN = 31;
        const long SCE_RB_STDOUT = 40;
        const long SCE_RB_STDERR = 41;
        const long SCE_RB_UPPER_BOUND = 42;
        const long SCE_B_DEFAULT = 0;
        const long SCE_B_COMMENT = 1;
        const long SCE_B_NUMBER = 2;
        const long SCE_B_KEYWORD = 3;
        const long SCE_B_STRING = 4;
        const long SCE_B_PREPROCESSOR = 5;
        const long SCE_B_OPERATOR = 6;
        const long SCE_B_IDENTIFIER = 7;
        const long SCE_B_DATE = 8;
        const long SCE_B_STRINGEOL = 9;
        const long SCE_B_KEYWORD2 = 10;
        const long SCE_B_KEYWORD3 = 11;
        const long SCE_B_KEYWORD4 = 12;
        const long SCE_B_CONSTANT = 13;
        const long SCE_B_ASM = 14;
        const long SCE_B_LABEL = 15;
        const long SCE_B_ERROR = 16;
        const long SCE_B_HEXNUMBER = 17;
        const long SCE_B_BINNUMBER = 18;
        const long SCE_PROPS_DEFAULT = 0;
        const long SCE_PROPS_COMMENT = 1;
        const long SCE_PROPS_SECTION = 2;
        const long SCE_PROPS_ASSIGNMENT = 3;
        const long SCE_PROPS_DEFVAL = 4;
        const long SCE_PROPS_KEY = 5;
        const long SCE_L_DEFAULT = 0;
        const long SCE_L_COMMAND = 1;
        const long SCE_L_TAG = 2;
        const long SCE_L_MATH = 3;
        const long SCE_L_COMMENT = 4;
        const long SCE_L_TAG2 = 5;
        const long SCE_L_MATH2 = 6;
        const long SCE_L_COMMENT2 = 7;
        const long SCE_L_VERBATIM = 8;
        const long SCE_L_SHORTCMD = 9;
        const long SCE_L_SPECIAL = 10;
        const long SCE_L_CMDOPT = 11;
        const long SCE_L_ERROR = 12;
        const long SCE_LUA_DEFAULT = 0;
        const long SCE_LUA_COMMENT = 1;
        const long SCE_LUA_COMMENTLINE = 2;
        const long SCE_LUA_COMMENTDOC = 3;
        const long SCE_LUA_NUMBER = 4;
        const long SCE_LUA_WORD = 5;
        const long SCE_LUA_STRING = 6;
        const long SCE_LUA_CHARACTER = 7;
        const long SCE_LUA_LITERALSTRING = 8;
        const long SCE_LUA_PREPROCESSOR = 9;
        const long SCE_LUA_OPERATOR = 10;
        const long SCE_LUA_IDENTIFIER = 11;
        const long SCE_LUA_STRINGEOL = 12;
        const long SCE_LUA_WORD2 = 13;
        const long SCE_LUA_WORD3 = 14;
        const long SCE_LUA_WORD4 = 15;
        const long SCE_LUA_WORD5 = 16;
        const long SCE_LUA_WORD6 = 17;
        const long SCE_LUA_WORD7 = 18;
        const long SCE_LUA_WORD8 = 19;
        const long SCE_LUA_LABEL = 20;
        const long SCE_ERR_DEFAULT = 0;
        const long SCE_ERR_PYTHON = 1;
        const long SCE_ERR_GCC = 2;
        const long SCE_ERR_MS = 3;
        const long SCE_ERR_CMD = 4;
        const long SCE_ERR_BORLAND = 5;
        const long SCE_ERR_PERL = 6;
        const long SCE_ERR_NET = 7;
        const long SCE_ERR_LUA = 8;
        const long SCE_ERR_CTAG = 9;
        const long SCE_ERR_DIFF_CHANGED = 10;
        const long SCE_ERR_DIFF_ADDITION = 11;
        const long SCE_ERR_DIFF_DELETION = 12;
        const long SCE_ERR_DIFF_MESSAGE = 13;
        const long SCE_ERR_PHP = 14;
        const long SCE_ERR_ELF = 15;
        const long SCE_ERR_IFC = 16;
        const long SCE_ERR_IFORT = 17;
        const long SCE_ERR_ABSF = 18;
        const long SCE_ERR_TIDY = 19;
        const long SCE_ERR_JAVA_STACK = 20;
        const long SCE_ERR_VALUE = 21;
        const long SCE_ERR_GCC_INCLUDED_FROM = 22;
        const long SCE_BAT_DEFAULT = 0;
        const long SCE_BAT_COMMENT = 1;
        const long SCE_BAT_WORD = 2;
        const long SCE_BAT_LABEL = 3;
        const long SCE_BAT_HIDE = 4;
        const long SCE_BAT_COMMAND = 5;
        const long SCE_BAT_IDENTIFIER = 6;
        const long SCE_BAT_OPERATOR = 7;
        const long SCE_TCMD_DEFAULT = 0;
        const long SCE_TCMD_COMMENT = 1;
        const long SCE_TCMD_WORD = 2;
        const long SCE_TCMD_LABEL = 3;
        const long SCE_TCMD_HIDE = 4;
        const long SCE_TCMD_COMMAND = 5;
        const long SCE_TCMD_IDENTIFIER = 6;
        const long SCE_TCMD_OPERATOR = 7;
        const long SCE_TCMD_ENVIRONMENT = 8;
        const long SCE_TCMD_EXPANSION = 9;
        const long SCE_TCMD_CLABEL = 10;
        const long SCE_MAKE_DEFAULT = 0;
        const long SCE_MAKE_COMMENT = 1;
        const long SCE_MAKE_PREPROCESSOR = 2;
        const long SCE_MAKE_IDENTIFIER = 3;
        const long SCE_MAKE_OPERATOR = 4;
        const long SCE_MAKE_TARGET = 5;
        const long SCE_MAKE_IDEOL = 9;
        const long SCE_DIFF_DEFAULT = 0;
        const long SCE_DIFF_COMMENT = 1;
        const long SCE_DIFF_COMMAND = 2;
        const long SCE_DIFF_HEADER = 3;
        const long SCE_DIFF_POSITION = 4;
        const long SCE_DIFF_DELETED = 5;
        const long SCE_DIFF_ADDED = 6;
        const long SCE_DIFF_CHANGED = 7;
        const long SCE_CONF_DEFAULT = 0;
        const long SCE_CONF_COMMENT = 1;
        const long SCE_CONF_NUMBER = 2;
        const long SCE_CONF_IDENTIFIER = 3;
        const long SCE_CONF_EXTENSION = 4;
        const long SCE_CONF_PARAMETER = 5;
        const long SCE_CONF_STRING = 6;
        const long SCE_CONF_OPERATOR = 7;
        const long SCE_CONF_IP = 8;
        const long SCE_CONF_DIRECTIVE = 9;
        const long SCE_AVE_DEFAULT = 0;
        const long SCE_AVE_COMMENT = 1;
        const long SCE_AVE_NUMBER = 2;
        const long SCE_AVE_WORD = 3;
        const long SCE_AVE_STRING = 6;
        const long SCE_AVE_ENUM = 7;
        const long SCE_AVE_STRINGEOL = 8;
        const long SCE_AVE_IDENTIFIER = 9;
        const long SCE_AVE_OPERATOR = 10;
        const long SCE_AVE_WORD1 = 11;
        const long SCE_AVE_WORD2 = 12;
        const long SCE_AVE_WORD3 = 13;
        const long SCE_AVE_WORD4 = 14;
        const long SCE_AVE_WORD5 = 15;
        const long SCE_AVE_WORD6 = 16;
        const long SCE_ADA_DEFAULT = 0;
        const long SCE_ADA_WORD = 1;
        const long SCE_ADA_IDENTIFIER = 2;
        const long SCE_ADA_NUMBER = 3;
        const long SCE_ADA_DELIMITER = 4;
        const long SCE_ADA_CHARACTER = 5;
        const long SCE_ADA_CHARACTEREOL = 6;
        const long SCE_ADA_STRING = 7;
        const long SCE_ADA_STRINGEOL = 8;
        const long SCE_ADA_LABEL = 9;
        const long SCE_ADA_COMMENTLINE = 10;
        const long SCE_ADA_ILLEGAL = 11;
        const long SCE_BAAN_DEFAULT = 0;
        const long SCE_BAAN_COMMENT = 1;
        const long SCE_BAAN_COMMENTDOC = 2;
        const long SCE_BAAN_NUMBER = 3;
        const long SCE_BAAN_WORD = 4;
        const long SCE_BAAN_STRING = 5;
        const long SCE_BAAN_PREPROCESSOR = 6;
        const long SCE_BAAN_OPERATOR = 7;
        const long SCE_BAAN_IDENTIFIER = 8;
        const long SCE_BAAN_STRINGEOL = 9;
        const long SCE_BAAN_WORD2 = 10;
        const long SCE_LISP_DEFAULT = 0;
        const long SCE_LISP_COMMENT = 1;
        const long SCE_LISP_NUMBER = 2;
        const long SCE_LISP_KEYWORD = 3;
        const long SCE_LISP_KEYWORD_KW = 4;
        const long SCE_LISP_SYMBOL = 5;
        const long SCE_LISP_STRING = 6;
        const long SCE_LISP_STRINGEOL = 8;
        const long SCE_LISP_IDENTIFIER = 9;
        const long SCE_LISP_OPERATOR = 10;
        const long SCE_LISP_SPECIAL = 11;
        const long SCE_LISP_MULTI_COMMENT = 12;
        const long SCE_EIFFEL_DEFAULT = 0;
        const long SCE_EIFFEL_COMMENTLINE = 1;
        const long SCE_EIFFEL_NUMBER = 2;
        const long SCE_EIFFEL_WORD = 3;
        const long SCE_EIFFEL_STRING = 4;
        const long SCE_EIFFEL_CHARACTER = 5;
        const long SCE_EIFFEL_OPERATOR = 6;
        const long SCE_EIFFEL_IDENTIFIER = 7;
        const long SCE_EIFFEL_STRINGEOL = 8;
        const long SCE_NNCRONTAB_DEFAULT = 0;
        const long SCE_NNCRONTAB_COMMENT = 1;
        const long SCE_NNCRONTAB_TASK = 2;
        const long SCE_NNCRONTAB_SECTION = 3;
        const long SCE_NNCRONTAB_KEYWORD = 4;
        const long SCE_NNCRONTAB_MODIFIER = 5;
        const long SCE_NNCRONTAB_ASTERISK = 6;
        const long SCE_NNCRONTAB_NUMBER = 7;
        const long SCE_NNCRONTAB_STRING = 8;
        const long SCE_NNCRONTAB_ENVIRONMENT = 9;
        const long SCE_NNCRONTAB_IDENTIFIER = 10;
        const long SCE_FORTH_DEFAULT = 0;
        const long SCE_FORTH_COMMENT = 1;
        const long SCE_FORTH_COMMENT_ML = 2;
        const long SCE_FORTH_IDENTIFIER = 3;
        const long SCE_FORTH_CONTROL = 4;
        const long SCE_FORTH_KEYWORD = 5;
        const long SCE_FORTH_DEFWORD = 6;
        const long SCE_FORTH_PREWORD1 = 7;
        const long SCE_FORTH_PREWORD2 = 8;
        const long SCE_FORTH_NUMBER = 9;
        const long SCE_FORTH_STRING = 10;
        const long SCE_FORTH_LOCALE = 11;
        const long SCE_MATLAB_DEFAULT = 0;
        const long SCE_MATLAB_COMMENT = 1;
        const long SCE_MATLAB_COMMAND = 2;
        const long SCE_MATLAB_NUMBER = 3;
        const long SCE_MATLAB_KEYWORD = 4;
        const long SCE_MATLAB_STRING = 5;
        const long SCE_MATLAB_OPERATOR = 6;
        const long SCE_MATLAB_IDENTIFIER = 7;
        const long SCE_MATLAB_DOUBLEQUOTESTRING = 8;
        const long SCE_SCRIPTOL_DEFAULT = 0;
        const long SCE_SCRIPTOL_WHITE = 1;
        const long SCE_SCRIPTOL_COMMENTLINE = 2;
        const long SCE_SCRIPTOL_PERSISTENT = 3;
        const long SCE_SCRIPTOL_CSTYLE = 4;
        const long SCE_SCRIPTOL_COMMENTBLOCK = 5;
        const long SCE_SCRIPTOL_NUMBER = 6;
        const long SCE_SCRIPTOL_STRING = 7;
        const long SCE_SCRIPTOL_CHARACTER = 8;
        const long SCE_SCRIPTOL_STRINGEOL = 9;
        const long SCE_SCRIPTOL_KEYWORD = 10;
        const long SCE_SCRIPTOL_OPERATOR = 11;
        const long SCE_SCRIPTOL_IDENTIFIER = 12;
        const long SCE_SCRIPTOL_TRIPLE = 13;
        const long SCE_SCRIPTOL_CLASSNAME = 14;
        const long SCE_SCRIPTOL_PREPROCESSOR = 15;
        const long SCE_ASM_DEFAULT = 0;
        const long SCE_ASM_COMMENT = 1;
        const long SCE_ASM_NUMBER = 2;
        const long SCE_ASM_STRING = 3;
        const long SCE_ASM_OPERATOR = 4;
        const long SCE_ASM_IDENTIFIER = 5;
        const long SCE_ASM_CPUINSTRUCTION = 6;
        const long SCE_ASM_MATHINSTRUCTION = 7;
        const long SCE_ASM_REGISTER = 8;
        const long SCE_ASM_DIRECTIVE = 9;
        const long SCE_ASM_DIRECTIVEOPERAND = 10;
        const long SCE_ASM_COMMENTBLOCK = 11;
        const long SCE_ASM_CHARACTER = 12;
        const long SCE_ASM_STRINGEOL = 13;
        const long SCE_ASM_EXTINSTRUCTION = 14;
        const long SCE_ASM_COMMENTDIRECTIVE = 15;
        const long SCE_F_DEFAULT = 0;
        const long SCE_F_COMMENT = 1;
        const long SCE_F_NUMBER = 2;
        const long SCE_F_STRING1 = 3;
        const long SCE_F_STRING2 = 4;
        const long SCE_F_STRINGEOL = 5;
        const long SCE_F_OPERATOR = 6;
        const long SCE_F_IDENTIFIER = 7;
        const long SCE_F_WORD = 8;
        const long SCE_F_WORD2 = 9;
        const long SCE_F_WORD3 = 10;
        const long SCE_F_PREPROCESSOR = 11;
        const long SCE_F_OPERATOR2 = 12;
        const long SCE_F_LABEL = 13;
        const long SCE_F_CONTINUATION = 14;
        const long SCE_CSS_DEFAULT = 0;
        const long SCE_CSS_TAG = 1;
        const long SCE_CSS_CLASS = 2;
        const long SCE_CSS_PSEUDOCLASS = 3;
        const long SCE_CSS_UNKNOWN_PSEUDOCLASS = 4;
        const long SCE_CSS_OPERATOR = 5;
        const long SCE_CSS_IDENTIFIER = 6;
        const long SCE_CSS_UNKNOWN_IDENTIFIER = 7;
        const long SCE_CSS_VALUE = 8;
        const long SCE_CSS_COMMENT = 9;
        const long SCE_CSS_ID = 10;
        const long SCE_CSS_IMPORTANT = 11;
        const long SCE_CSS_DIRECTIVE = 12;
        const long SCE_CSS_DOUBLESTRING = 13;
        const long SCE_CSS_SINGLESTRING = 14;
        const long SCE_CSS_IDENTIFIER2 = 15;
        const long SCE_CSS_ATTRIBUTE = 16;
        const long SCE_CSS_IDENTIFIER3 = 17;
        const long SCE_CSS_PSEUDOELEMENT = 18;
        const long SCE_CSS_EXTENDED_IDENTIFIER = 19;
        const long SCE_CSS_EXTENDED_PSEUDOCLASS = 20;
        const long SCE_CSS_EXTENDED_PSEUDOELEMENT = 21;
        const long SCE_CSS_MEDIA = 22;
        const long SCE_CSS_VARIABLE = 23;
        const long SCE_CSS_NUMBER = 24;
        const long SCE_CSS_STRINGEOL = 25;
        const long SCE_CSS_MIXIN = 26;
        const long SCE_POV_DEFAULT = 0;
        const long SCE_POV_COMMENT = 1;
        const long SCE_POV_COMMENTLINE = 2;
        const long SCE_POV_NUMBER = 3;
        const long SCE_POV_OPERATOR = 4;
        const long SCE_POV_IDENTIFIER = 5;
        const long SCE_POV_STRING = 6;
        const long SCE_POV_STRINGEOL = 7;
        const long SCE_POV_DIRECTIVE = 8;
        const long SCE_POV_BADDIRECTIVE = 9;
        const long SCE_POV_WORD2 = 10;
        const long SCE_POV_WORD3 = 11;
        const long SCE_POV_WORD4 = 12;
        const long SCE_POV_WORD5 = 13;
        const long SCE_POV_WORD6 = 14;
        const long SCE_POV_WORD7 = 15;
        const long SCE_POV_WORD8 = 16;
        const long SCE_LOUT_DEFAULT = 0;
        const long SCE_LOUT_COMMENT = 1;
        const long SCE_LOUT_NUMBER = 2;
        const long SCE_LOUT_WORD = 3;
        const long SCE_LOUT_WORD2 = 4;
        const long SCE_LOUT_WORD3 = 5;
        const long SCE_LOUT_WORD4 = 6;
        const long SCE_LOUT_STRING = 7;
        const long SCE_LOUT_OPERATOR = 8;
        const long SCE_LOUT_IDENTIFIER = 9;
        const long SCE_LOUT_STRINGEOL = 10;
        const long SCE_ESCRIPT_DEFAULT = 0;
        const long SCE_ESCRIPT_COMMENT = 1;
        const long SCE_ESCRIPT_COMMENTLINE = 2;
        const long SCE_ESCRIPT_COMMENTDOC = 3;
        const long SCE_ESCRIPT_NUMBER = 4;
        const long SCE_ESCRIPT_WORD = 5;
        const long SCE_ESCRIPT_STRING = 6;
        const long SCE_ESCRIPT_OPERATOR = 7;
        const long SCE_ESCRIPT_IDENTIFIER = 8;
        const long SCE_ESCRIPT_BRACE = 9;
        const long SCE_ESCRIPT_WORD2 = 10;
        const long SCE_ESCRIPT_WORD3 = 11;
        const long SCE_PS_DEFAULT = 0;
        const long SCE_PS_COMMENT = 1;
        const long SCE_PS_DSC_COMMENT = 2;
        const long SCE_PS_DSC_VALUE = 3;
        const long SCE_PS_NUMBER = 4;
        const long SCE_PS_NAME = 5;
        const long SCE_PS_KEYWORD = 6;
        const long SCE_PS_LITERAL = 7;
        const long SCE_PS_IMMEVAL = 8;
        const long SCE_PS_PAREN_ARRAY = 9;
        const long SCE_PS_PAREN_DICT = 10;
        const long SCE_PS_PAREN_PROC = 11;
        const long SCE_PS_TEXT = 12;
        const long SCE_PS_HEXSTRING = 13;
        const long SCE_PS_BASE85STRING = 14;
        const long SCE_PS_BADSTRINGCHAR = 15;
        const long SCE_NSIS_DEFAULT = 0;
        const long SCE_NSIS_COMMENT = 1;
        const long SCE_NSIS_STRINGDQ = 2;
        const long SCE_NSIS_STRINGLQ = 3;
        const long SCE_NSIS_STRINGRQ = 4;
        const long SCE_NSIS_FUNCTION = 5;
        const long SCE_NSIS_VARIABLE = 6;
        const long SCE_NSIS_LABEL = 7;
        const long SCE_NSIS_USERDEFINED = 8;
        const long SCE_NSIS_SECTIONDEF = 9;
        const long SCE_NSIS_SUBSECTIONDEF = 10;
        const long SCE_NSIS_IFDEFINEDEF = 11;
        const long SCE_NSIS_MACRODEF = 12;
        const long SCE_NSIS_STRINGVAR = 13;
        const long SCE_NSIS_NUMBER = 14;
        const long SCE_NSIS_SECTIONGROUP = 15;
        const long SCE_NSIS_PAGEEX = 16;
        const long SCE_NSIS_FUNCTIONDEF = 17;
        const long SCE_NSIS_COMMENTBOX = 18;
        const long SCE_MMIXAL_LEADWS = 0;
        const long SCE_MMIXAL_COMMENT = 1;
        const long SCE_MMIXAL_LABEL = 2;
        const long SCE_MMIXAL_OPCODE = 3;
        const long SCE_MMIXAL_OPCODE_PRE = 4;
        const long SCE_MMIXAL_OPCODE_VALID = 5;
        const long SCE_MMIXAL_OPCODE_UNKNOWN = 6;
        const long SCE_MMIXAL_OPCODE_POST = 7;
        const long SCE_MMIXAL_OPERANDS = 8;
        const long SCE_MMIXAL_NUMBER = 9;
        const long SCE_MMIXAL_REF = 10;
        const long SCE_MMIXAL_CHAR = 11;
        const long SCE_MMIXAL_STRING = 12;
        const long SCE_MMIXAL_REGISTER = 13;
        const long SCE_MMIXAL_HEX = 14;
        const long SCE_MMIXAL_OPERATOR = 15;
        const long SCE_MMIXAL_SYMBOL = 16;
        const long SCE_MMIXAL_INCLUDE = 17;
        const long SCE_CLW_DEFAULT = 0;
        const long SCE_CLW_LABEL = 1;
        const long SCE_CLW_COMMENT = 2;
        const long SCE_CLW_STRING = 3;
        const long SCE_CLW_USER_IDENTIFIER = 4;
        const long SCE_CLW_INTEGER_CONSTANT = 5;
        const long SCE_CLW_REAL_CONSTANT = 6;
        const long SCE_CLW_PICTURE_STRING = 7;
        const long SCE_CLW_KEYWORD = 8;
        const long SCE_CLW_COMPILER_DIRECTIVE = 9;
        const long SCE_CLW_RUNTIME_EXPRESSIONS = 10;
        const long SCE_CLW_BUILTIN_PROCEDURES_FUNCTION = 11;
        const long SCE_CLW_STRUCTURE_DATA_TYPE = 12;
        const long SCE_CLW_ATTRIBUTE = 13;
        const long SCE_CLW_STANDARD_EQUATE = 14;
        const long SCE_CLW_ERROR = 15;
        const long SCE_CLW_DEPRECATED = 16;
        const long SCE_LOT_DEFAULT = 0;
        const long SCE_LOT_HEADER = 1;
        const long SCE_LOT_BREAK = 2;
        const long SCE_LOT_SET = 3;
        const long SCE_LOT_PASS = 4;
        const long SCE_LOT_FAIL = 5;
        const long SCE_LOT_ABORT = 6;
        const long SCE_YAML_DEFAULT = 0;
        const long SCE_YAML_COMMENT = 1;
        const long SCE_YAML_IDENTIFIER = 2;
        const long SCE_YAML_KEYWORD = 3;
        const long SCE_YAML_NUMBER = 4;
        const long SCE_YAML_REFERENCE = 5;
        const long SCE_YAML_DOCUMENT = 6;
        const long SCE_YAML_TEXT = 7;
        const long SCE_YAML_ERROR = 8;
        const long SCE_YAML_OPERATOR = 9;
        const long SCE_TEX_DEFAULT = 0;
        const long SCE_TEX_SPECIAL = 1;
        const long SCE_TEX_GROUP = 2;
        const long SCE_TEX_SYMBOL = 3;
        const long SCE_TEX_COMMAND = 4;
        const long SCE_TEX_TEXT = 5;
        const long SCE_METAPOST_DEFAULT = 0;
        const long SCE_METAPOST_SPECIAL = 1;
        const long SCE_METAPOST_GROUP = 2;
        const long SCE_METAPOST_SYMBOL = 3;
        const long SCE_METAPOST_COMMAND = 4;
        const long SCE_METAPOST_TEXT = 5;
        const long SCE_METAPOST_EXTRA = 6;
        const long SCE_ERLANG_DEFAULT = 0;
        const long SCE_ERLANG_COMMENT = 1;
        const long SCE_ERLANG_VARIABLE = 2;
        const long SCE_ERLANG_NUMBER = 3;
        const long SCE_ERLANG_KEYWORD = 4;
        const long SCE_ERLANG_STRING = 5;
        const long SCE_ERLANG_OPERATOR = 6;
        const long SCE_ERLANG_ATOM = 7;
        const long SCE_ERLANG_FUNCTION_NAME = 8;
        const long SCE_ERLANG_CHARACTER = 9;
        const long SCE_ERLANG_MACRO = 10;
        const long SCE_ERLANG_RECORD = 11;
        const long SCE_ERLANG_PREPROC = 12;
        const long SCE_ERLANG_NODE_NAME = 13;
        const long SCE_ERLANG_COMMENT_FUNCTION = 14;
        const long SCE_ERLANG_COMMENT_MODULE = 15;
        const long SCE_ERLANG_COMMENT_DOC = 16;
        const long SCE_ERLANG_COMMENT_DOC_MACRO = 17;
        const long SCE_ERLANG_ATOM_QUOTED = 18;
        const long SCE_ERLANG_MACRO_QUOTED = 19;
        const long SCE_ERLANG_RECORD_QUOTED = 20;
        const long SCE_ERLANG_NODE_NAME_QUOTED = 21;
        const long SCE_ERLANG_BIFS = 22;
        const long SCE_ERLANG_MODULES = 23;
        const long SCE_ERLANG_MODULES_ATT = 24;
        const long SCE_ERLANG_UNKNOWN = 31;
        const long SCE_MSSQL_DEFAULT = 0;
        const long SCE_MSSQL_COMMENT = 1;
        const long SCE_MSSQL_LINE_COMMENT = 2;
        const long SCE_MSSQL_NUMBER = 3;
        const long SCE_MSSQL_STRING = 4;
        const long SCE_MSSQL_OPERATOR = 5;
        const long SCE_MSSQL_IDENTIFIER = 6;
        const long SCE_MSSQL_VARIABLE = 7;
        const long SCE_MSSQL_COLUMN_NAME = 8;
        const long SCE_MSSQL_STATEMENT = 9;
        const long SCE_MSSQL_DATATYPE = 10;
        const long SCE_MSSQL_SYSTABLE = 11;
        const long SCE_MSSQL_GLOBAL_VARIABLE = 12;
        const long SCE_MSSQL_FUNCTION = 13;
        const long SCE_MSSQL_STORED_PROCEDURE = 14;
        const long SCE_MSSQL_DEFAULT_PREF_DATATYPE = 15;
        const long SCE_MSSQL_COLUMN_NAME_2 = 16;
        const long SCE_V_DEFAULT = 0;
        const long SCE_V_COMMENT = 1;
        const long SCE_V_COMMENTLINE = 2;
        const long SCE_V_COMMENTLINEBANG = 3;
        const long SCE_V_NUMBER = 4;
        const long SCE_V_WORD = 5;
        const long SCE_V_STRING = 6;
        const long SCE_V_WORD2 = 7;
        const long SCE_V_WORD3 = 8;
        const long SCE_V_PREPROCESSOR = 9;
        const long SCE_V_OPERATOR = 10;
        const long SCE_V_IDENTIFIER = 11;
        const long SCE_V_STRINGEOL = 12;
        const long SCE_V_USER = 19;
        const long SCE_KIX_DEFAULT = 0;
        const long SCE_KIX_COMMENT = 1;
        const long SCE_KIX_STRING1 = 2;
        const long SCE_KIX_STRING2 = 3;
        const long SCE_KIX_NUMBER = 4;
        const long SCE_KIX_VAR = 5;
        const long SCE_KIX_MACRO = 6;
        const long SCE_KIX_KEYWORD = 7;
        const long SCE_KIX_FUNCTIONS = 8;
        const long SCE_KIX_OPERATOR = 9;
        const long SCE_KIX_IDENTIFIER = 31;
        const long SCE_GC_DEFAULT = 0;
        const long SCE_GC_COMMENTLINE = 1;
        const long SCE_GC_COMMENTBLOCK = 2;
        const long SCE_GC_GLOBAL = 3;
        const long SCE_GC_EVENT = 4;
        const long SCE_GC_ATTRIBUTE = 5;
        const long SCE_GC_CONTROL = 6;
        const long SCE_GC_COMMAND = 7;
        const long SCE_GC_STRING = 8;
        const long SCE_GC_OPERATOR = 9;
        const long SCE_SN_DEFAULT = 0;
        const long SCE_SN_CODE = 1;
        const long SCE_SN_COMMENTLINE = 2;
        const long SCE_SN_COMMENTLINEBANG = 3;
        const long SCE_SN_NUMBER = 4;
        const long SCE_SN_WORD = 5;
        const long SCE_SN_STRING = 6;
        const long SCE_SN_WORD2 = 7;
        const long SCE_SN_WORD3 = 8;
        const long SCE_SN_PREPROCESSOR = 9;
        const long SCE_SN_OPERATOR = 10;
        const long SCE_SN_IDENTIFIER = 11;
        const long SCE_SN_STRINGEOL = 12;
        const long SCE_SN_REGEXTAG = 13;
        const long SCE_SN_SIGNAL = 14;
        const long SCE_SN_USER = 19;
        const long SCE_AU3_DEFAULT = 0;
        const long SCE_AU3_COMMENT = 1;
        const long SCE_AU3_COMMENTBLOCK = 2;
        const long SCE_AU3_NUMBER = 3;
        const long SCE_AU3_FUNCTION = 4;
        const long SCE_AU3_KEYWORD = 5;
        const long SCE_AU3_MACRO = 6;
        const long SCE_AU3_STRING = 7;
        const long SCE_AU3_OPERATOR = 8;
        const long SCE_AU3_VARIABLE = 9;
        const long SCE_AU3_SENT = 10;
        const long SCE_AU3_PREPROCESSOR = 11;
        const long SCE_AU3_SPECIAL = 12;
        const long SCE_AU3_EXPAND = 13;
        const long SCE_AU3_COMOBJ = 14;
        const long SCE_AU3_UDF = 15;
        const long SCE_APDL_DEFAULT = 0;
        const long SCE_APDL_COMMENT = 1;
        const long SCE_APDL_COMMENTBLOCK = 2;
        const long SCE_APDL_NUMBER = 3;
        const long SCE_APDL_STRING = 4;
        const long SCE_APDL_OPERATOR = 5;
        const long SCE_APDL_WORD = 6;
        const long SCE_APDL_PROCESSOR = 7;
        const long SCE_APDL_COMMAND = 8;
        const long SCE_APDL_SLASHCOMMAND = 9;
        const long SCE_APDL_STARCOMMAND = 10;
        const long SCE_APDL_ARGUMENT = 11;
        const long SCE_APDL_FUNCTION = 12;
        const long SCE_SH_DEFAULT = 0;
        const long SCE_SH_ERROR = 1;
        const long SCE_SH_COMMENTLINE = 2;
        const long SCE_SH_NUMBER = 3;
        const long SCE_SH_WORD = 4;
        const long SCE_SH_STRING = 5;
        const long SCE_SH_CHARACTER = 6;
        const long SCE_SH_OPERATOR = 7;
        const long SCE_SH_IDENTIFIER = 8;
        const long SCE_SH_SCALAR = 9;
        const long SCE_SH_PARAM = 10;
        const long SCE_SH_BACKTICKS = 11;
        const long SCE_SH_HERE_DELIM = 12;
        const long SCE_SH_HERE_Q = 13;
        const long SCE_ASN1_DEFAULT = 0;
        const long SCE_ASN1_COMMENT = 1;
        const long SCE_ASN1_IDENTIFIER = 2;
        const long SCE_ASN1_STRING = 3;
        const long SCE_ASN1_OID = 4;
        const long SCE_ASN1_SCALAR = 5;
        const long SCE_ASN1_KEYWORD = 6;
        const long SCE_ASN1_ATTRIBUTE = 7;
        const long SCE_ASN1_DESCRIPTOR = 8;
        const long SCE_ASN1_TYPE = 9;
        const long SCE_ASN1_OPERATOR = 10;
        const long SCE_VHDL_DEFAULT = 0;
        const long SCE_VHDL_COMMENT = 1;
        const long SCE_VHDL_COMMENTLINEBANG = 2;
        const long SCE_VHDL_NUMBER = 3;
        const long SCE_VHDL_STRING = 4;
        const long SCE_VHDL_OPERATOR = 5;
        const long SCE_VHDL_IDENTIFIER = 6;
        const long SCE_VHDL_STRINGEOL = 7;
        const long SCE_VHDL_KEYWORD = 8;
        const long SCE_VHDL_STDOPERATOR = 9;
        const long SCE_VHDL_ATTRIBUTE = 10;
        const long SCE_VHDL_STDFUNCTION = 11;
        const long SCE_VHDL_STDPACKAGE = 12;
        const long SCE_VHDL_STDTYPE = 13;
        const long SCE_VHDL_USERWORD = 14;
        const long SCE_CAML_DEFAULT = 0;
        const long SCE_CAML_IDENTIFIER = 1;
        const long SCE_CAML_TAGNAME = 2;
        const long SCE_CAML_KEYWORD = 3;
        const long SCE_CAML_KEYWORD2 = 4;
        const long SCE_CAML_KEYWORD3 = 5;
        const long SCE_CAML_LINENUM = 6;
        const long SCE_CAML_OPERATOR = 7;
        const long SCE_CAML_NUMBER = 8;
        const long SCE_CAML_CHAR = 9;
        const long SCE_CAML_WHITE = 10;
        const long SCE_CAML_STRING = 11;
        const long SCE_CAML_COMMENT = 12;
        const long SCE_CAML_COMMENT1 = 13;
        const long SCE_CAML_COMMENT2 = 14;
        const long SCE_CAML_COMMENT3 = 15;
        const long SCE_HA_DEFAULT = 0;
        const long SCE_HA_IDENTIFIER = 1;
        const long SCE_HA_KEYWORD = 2;
        const long SCE_HA_NUMBER = 3;
        const long SCE_HA_STRING = 4;
        const long SCE_HA_CHARACTER = 5;
        const long SCE_HA_CLASS = 6;
        const long SCE_HA_MODULE = 7;
        const long SCE_HA_CAPITAL = 8;
        const long SCE_HA_DATA = 9;
        const long SCE_HA_IMPORT = 10;
        const long SCE_HA_OPERATOR = 11;
        const long SCE_HA_INSTANCE = 12;
        const long SCE_HA_COMMENTLINE = 13;
        const long SCE_HA_COMMENTBLOCK = 14;
        const long SCE_HA_COMMENTBLOCK2 = 15;
        const long SCE_HA_COMMENTBLOCK3 = 16;
        const long SCE_HA_PRAGMA = 17;
        const long SCE_HA_PREPROCESSOR = 18;
        const long SCE_HA_STRINGEOL = 19;
        const long SCE_HA_RESERVED_OPERATOR = 20;
        const long SCE_HA_LITERATE_COMMENT = 21;
        const long SCE_HA_LITERATE_CODEDELIM = 22;
        const long SCE_T3_DEFAULT = 0;
        const long SCE_T3_X_DEFAULT = 1;
        const long SCE_T3_PREPROCESSOR = 2;
        const long SCE_T3_BLOCK_COMMENT = 3;
        const long SCE_T3_LINE_COMMENT = 4;
        const long SCE_T3_OPERATOR = 5;
        const long SCE_T3_KEYWORD = 6;
        const long SCE_T3_NUMBER = 7;
        const long SCE_T3_IDENTIFIER = 8;
        const long SCE_T3_S_STRING = 9;
        const long SCE_T3_D_STRING = 10;
        const long SCE_T3_X_STRING = 11;
        const long SCE_T3_LIB_DIRECTIVE = 12;
        const long SCE_T3_MSG_PARAM = 13;
        const long SCE_T3_HTML_TAG = 14;
        const long SCE_T3_HTML_DEFAULT = 15;
        const long SCE_T3_HTML_STRING = 16;
        const long SCE_T3_USER1 = 17;
        const long SCE_T3_USER2 = 18;
        const long SCE_T3_USER3 = 19;
        const long SCE_T3_BRACE = 20;
        const long SCE_REBOL_DEFAULT = 0;
        const long SCE_REBOL_COMMENTLINE = 1;
        const long SCE_REBOL_COMMENTBLOCK = 2;
        const long SCE_REBOL_PREFACE = 3;
        const long SCE_REBOL_OPERATOR = 4;
        const long SCE_REBOL_CHARACTER = 5;
        const long SCE_REBOL_QUOTEDSTRING = 6;
        const long SCE_REBOL_BRACEDSTRING = 7;
        const long SCE_REBOL_NUMBER = 8;
        const long SCE_REBOL_PAIR = 9;
        const long SCE_REBOL_TUPLE = 10;
        const long SCE_REBOL_BINARY = 11;
        const long SCE_REBOL_MONEY = 12;
        const long SCE_REBOL_ISSUE = 13;
        const long SCE_REBOL_TAG = 14;
        const long SCE_REBOL_FILE = 15;
        const long SCE_REBOL_EMAIL = 16;
        const long SCE_REBOL_URL = 17;
        const long SCE_REBOL_DATE = 18;
        const long SCE_REBOL_TIME = 19;
        const long SCE_REBOL_IDENTIFIER = 20;
        const long SCE_REBOL_WORD = 21;
        const long SCE_REBOL_WORD2 = 22;
        const long SCE_REBOL_WORD3 = 23;
        const long SCE_REBOL_WORD4 = 24;
        const long SCE_REBOL_WORD5 = 25;
        const long SCE_REBOL_WORD6 = 26;
        const long SCE_REBOL_WORD7 = 27;
        const long SCE_REBOL_WORD8 = 28;
        const long SCE_SQL_DEFAULT = 0;
        const long SCE_SQL_COMMENT = 1;
        const long SCE_SQL_COMMENTLINE = 2;
        const long SCE_SQL_COMMENTDOC = 3;
        const long SCE_SQL_NUMBER = 4;
        const long SCE_SQL_WORD = 5;
        const long SCE_SQL_STRING = 6;
        const long SCE_SQL_CHARACTER = 7;
        const long SCE_SQL_SQLPLUS = 8;
        const long SCE_SQL_SQLPLUS_PROMPT = 9;
        const long SCE_SQL_OPERATOR = 10;
        const long SCE_SQL_IDENTIFIER = 11;
        const long SCE_SQL_SQLPLUS_COMMENT = 13;
        const long SCE_SQL_COMMENTLINEDOC = 15;
        const long SCE_SQL_WORD2 = 16;
        const long SCE_SQL_COMMENTDOCKEYWORD = 17;
        const long SCE_SQL_COMMENTDOCKEYWORDERROR = 18;
        const long SCE_SQL_USER1 = 19;
        const long SCE_SQL_USER2 = 20;
        const long SCE_SQL_USER3 = 21;
        const long SCE_SQL_USER4 = 22;
        const long SCE_SQL_QUOTEDIDENTIFIER = 23;
        const long SCE_ST_DEFAULT = 0;
        const long SCE_ST_STRING = 1;
        const long SCE_ST_NUMBER = 2;
        const long SCE_ST_COMMENT = 3;
        const long SCE_ST_SYMBOL = 4;
        const long SCE_ST_BINARY = 5;
        const long SCE_ST_BOOL = 6;
        const long SCE_ST_SELF = 7;
        const long SCE_ST_SUPER = 8;
        const long SCE_ST_NIL = 9;
        const long SCE_ST_GLOBAL = 10;
        const long SCE_ST_RETURN = 11;
        const long SCE_ST_SPECIAL = 12;
        const long SCE_ST_KWSEND = 13;
        const long SCE_ST_ASSIGN = 14;
        const long SCE_ST_CHARACTER = 15;
        const long SCE_ST_SPEC_SEL = 16;
        const long SCE_FS_DEFAULT = 0;
        const long SCE_FS_COMMENT = 1;
        const long SCE_FS_COMMENTLINE = 2;
        const long SCE_FS_COMMENTDOC = 3;
        const long SCE_FS_COMMENTLINEDOC = 4;
        const long SCE_FS_COMMENTDOCKEYWORD = 5;
        const long SCE_FS_COMMENTDOCKEYWORDERROR = 6;
        const long SCE_FS_KEYWORD = 7;
        const long SCE_FS_KEYWORD2 = 8;
        const long SCE_FS_KEYWORD3 = 9;
        const long SCE_FS_KEYWORD4 = 10;
        const long SCE_FS_NUMBER = 11;
        const long SCE_FS_STRING = 12;
        const long SCE_FS_PREPROCESSOR = 13;
        const long SCE_FS_OPERATOR = 14;
        const long SCE_FS_IDENTIFIER = 15;
        const long SCE_FS_DATE = 16;
        const long SCE_FS_STRINGEOL = 17;
        const long SCE_FS_CONSTANT = 18;
        const long SCE_FS_WORDOPERATOR = 19;
        const long SCE_FS_DISABLEDCODE = 20;
        const long SCE_FS_DEFAULT_C = 21;
        const long SCE_FS_COMMENTDOC_C = 22;
        const long SCE_FS_COMMENTLINEDOC_C = 23;
        const long SCE_FS_KEYWORD_C = 24;
        const long SCE_FS_KEYWORD2_C = 25;
        const long SCE_FS_NUMBER_C = 26;
        const long SCE_FS_STRING_C = 27;
        const long SCE_FS_PREPROCESSOR_C = 28;
        const long SCE_FS_OPERATOR_C = 29;
        const long SCE_FS_IDENTIFIER_C = 30;
        const long SCE_FS_STRINGEOL_C = 31;
        const long SCE_CSOUND_DEFAULT = 0;
        const long SCE_CSOUND_COMMENT = 1;
        const long SCE_CSOUND_NUMBER = 2;
        const long SCE_CSOUND_OPERATOR = 3;
        const long SCE_CSOUND_INSTR = 4;
        const long SCE_CSOUND_IDENTIFIER = 5;
        const long SCE_CSOUND_OPCODE = 6;
        const long SCE_CSOUND_HEADERSTMT = 7;
        const long SCE_CSOUND_USERKEYWORD = 8;
        const long SCE_CSOUND_COMMENTBLOCK = 9;
        const long SCE_CSOUND_PARAM = 10;
        const long SCE_CSOUND_ARATE_VAR = 11;
        const long SCE_CSOUND_KRATE_VAR = 12;
        const long SCE_CSOUND_IRATE_VAR = 13;
        const long SCE_CSOUND_GLOBAL_VAR = 14;
        const long SCE_CSOUND_STRINGEOL = 15;
        const long SCE_INNO_DEFAULT = 0;
        const long SCE_INNO_COMMENT = 1;
        const long SCE_INNO_KEYWORD = 2;
        const long SCE_INNO_PARAMETER = 3;
        const long SCE_INNO_SECTION = 4;
        const long SCE_INNO_PREPROC = 5;
        const long SCE_INNO_INLINE_EXPANSION = 6;
        const long SCE_INNO_COMMENT_PASCAL = 7;
        const long SCE_INNO_KEYWORD_PASCAL = 8;
        const long SCE_INNO_KEYWORD_USER = 9;
        const long SCE_INNO_STRING_DOUBLE = 10;
        const long SCE_INNO_STRING_SINGLE = 11;
        const long SCE_INNO_IDENTIFIER = 12;
        const long SCE_OPAL_SPACE = 0;
        const long SCE_OPAL_COMMENT_BLOCK = 1;
        const long SCE_OPAL_COMMENT_LINE = 2;
        const long SCE_OPAL_INTEGER = 3;
        const long SCE_OPAL_KEYWORD = 4;
        const long SCE_OPAL_SORT = 5;
        const long SCE_OPAL_STRING = 6;
        const long SCE_OPAL_PAR = 7;
        const long SCE_OPAL_BOOL_CONST = 8;
        const long SCE_OPAL_DEFAULT = 32;
        const long SCE_SPICE_DEFAULT = 0;
        const long SCE_SPICE_IDENTIFIER = 1;
        const long SCE_SPICE_KEYWORD = 2;
        const long SCE_SPICE_KEYWORD2 = 3;
        const long SCE_SPICE_KEYWORD3 = 4;
        const long SCE_SPICE_NUMBER = 5;
        const long SCE_SPICE_DELIMITER = 6;
        const long SCE_SPICE_VALUE = 7;
        const long SCE_SPICE_COMMENTLINE = 8;
        const long SCE_CMAKE_DEFAULT = 0;
        const long SCE_CMAKE_COMMENT = 1;
        const long SCE_CMAKE_STRINGDQ = 2;
        const long SCE_CMAKE_STRINGLQ = 3;
        const long SCE_CMAKE_STRINGRQ = 4;
        const long SCE_CMAKE_COMMANDS = 5;
        const long SCE_CMAKE_PARAMETERS = 6;
        const long SCE_CMAKE_VARIABLE = 7;
        const long SCE_CMAKE_USERDEFINED = 8;
        const long SCE_CMAKE_WHILEDEF = 9;
        const long SCE_CMAKE_FOREACHDEF = 10;
        const long SCE_CMAKE_IFDEFINEDEF = 11;
        const long SCE_CMAKE_MACRODEF = 12;
        const long SCE_CMAKE_STRINGVAR = 13;
        const long SCE_CMAKE_NUMBER = 14;
        const long SCE_GAP_DEFAULT = 0;
        const long SCE_GAP_IDENTIFIER = 1;
        const long SCE_GAP_KEYWORD = 2;
        const long SCE_GAP_KEYWORD2 = 3;
        const long SCE_GAP_KEYWORD3 = 4;
        const long SCE_GAP_KEYWORD4 = 5;
        const long SCE_GAP_STRING = 6;
        const long SCE_GAP_CHAR = 7;
        const long SCE_GAP_OPERATOR = 8;
        const long SCE_GAP_COMMENT = 9;
        const long SCE_GAP_NUMBER = 10;
        const long SCE_GAP_STRINGEOL = 11;
        const long SCE_PLM_DEFAULT = 0;
        const long SCE_PLM_COMMENT = 1;
        const long SCE_PLM_STRING = 2;
        const long SCE_PLM_NUMBER = 3;
        const long SCE_PLM_IDENTIFIER = 4;
        const long SCE_PLM_OPERATOR = 5;
        const long SCE_PLM_CONTROL = 6;
        const long SCE_PLM_KEYWORD = 7;
        const long SCE_4GL_DEFAULT = 0;
        const long SCE_4GL_NUMBER = 1;
        const long SCE_4GL_WORD = 2;
        const long SCE_4GL_STRING = 3;
        const long SCE_4GL_CHARACTER = 4;
        const long SCE_4GL_PREPROCESSOR = 5;
        const long SCE_4GL_OPERATOR = 6;
        const long SCE_4GL_IDENTIFIER = 7;
        const long SCE_4GL_BLOCK = 8;
        const long SCE_4GL_END = 9;
        const long SCE_4GL_COMMENT1 = 10;
        const long SCE_4GL_COMMENT2 = 11;
        const long SCE_4GL_COMMENT3 = 12;
        const long SCE_4GL_COMMENT4 = 13;
        const long SCE_4GL_COMMENT5 = 14;
        const long SCE_4GL_COMMENT6 = 15;
        const long SCE_4GL_DEFAULT_ = 16;
        const long SCE_4GL_NUMBER_ = 17;
        const long SCE_4GL_WORD_ = 18;
        const long SCE_4GL_STRING_ = 19;
        const long SCE_4GL_CHARACTER_ = 20;
        const long SCE_4GL_PREPROCESSOR_ = 21;
        const long SCE_4GL_OPERATOR_ = 22;
        const long SCE_4GL_IDENTIFIER_ = 23;
        const long SCE_4GL_BLOCK_ = 24;
        const long SCE_4GL_END_ = 25;
        const long SCE_4GL_COMMENT1_ = 26;
        const long SCE_4GL_COMMENT2_ = 27;
        const long SCE_4GL_COMMENT3_ = 28;
        const long SCE_4GL_COMMENT4_ = 29;
        const long SCE_4GL_COMMENT5_ = 30;
        const long SCE_4GL_COMMENT6_ = 31;
        const long SCE_ABAQUS_DEFAULT = 0;
        const long SCE_ABAQUS_COMMENT = 1;
        const long SCE_ABAQUS_COMMENTBLOCK = 2;
        const long SCE_ABAQUS_NUMBER = 3;
        const long SCE_ABAQUS_STRING = 4;
        const long SCE_ABAQUS_OPERATOR = 5;
        const long SCE_ABAQUS_WORD = 6;
        const long SCE_ABAQUS_PROCESSOR = 7;
        const long SCE_ABAQUS_COMMAND = 8;
        const long SCE_ABAQUS_SLASHCOMMAND = 9;
        const long SCE_ABAQUS_STARCOMMAND = 10;
        const long SCE_ABAQUS_ARGUMENT = 11;
        const long SCE_ABAQUS_FUNCTION = 12;
        const long SCE_ASY_DEFAULT = 0;
        const long SCE_ASY_COMMENT = 1;
        const long SCE_ASY_COMMENTLINE = 2;
        const long SCE_ASY_NUMBER = 3;
        const long SCE_ASY_WORD = 4;
        const long SCE_ASY_STRING = 5;
        const long SCE_ASY_CHARACTER = 6;
        const long SCE_ASY_OPERATOR = 7;
        const long SCE_ASY_IDENTIFIER = 8;
        const long SCE_ASY_STRINGEOL = 9;
        const long SCE_ASY_COMMENTLINEDOC = 10;
        const long SCE_ASY_WORD2 = 11;
        const long SCE_R_DEFAULT = 0;
        const long SCE_R_COMMENT = 1;
        const long SCE_R_KWORD = 2;
        const long SCE_R_BASEKWORD = 3;
        const long SCE_R_OTHERKWORD = 4;
        const long SCE_R_NUMBER = 5;
        const long SCE_R_STRING = 6;
        const long SCE_R_STRING2 = 7;
        const long SCE_R_OPERATOR = 8;
        const long SCE_R_IDENTIFIER = 9;
        const long SCE_R_INFIX = 10;
        const long SCE_R_INFIXEOL = 11;
        const long SCE_MAGIK_DEFAULT = 0;
        const long SCE_MAGIK_COMMENT = 1;
        const long SCE_MAGIK_HYPER_COMMENT = 16;
        const long SCE_MAGIK_STRING = 2;
        const long SCE_MAGIK_CHARACTER = 3;
        const long SCE_MAGIK_NUMBER = 4;
        const long SCE_MAGIK_IDENTIFIER = 5;
        const long SCE_MAGIK_OPERATOR = 6;
        const long SCE_MAGIK_FLOW = 7;
        const long SCE_MAGIK_CONTAINER = 8;
        const long SCE_MAGIK_BRACKET_BLOCK = 9;
        const long SCE_MAGIK_BRACE_BLOCK = 10;
        const long SCE_MAGIK_SQBRACKET_BLOCK = 11;
        const long SCE_MAGIK_UNKNOWN_KEYWORD = 12;
        const long SCE_MAGIK_KEYWORD = 13;
        const long SCE_MAGIK_PRAGMA = 14;
        const long SCE_MAGIK_SYMBOL = 15;
        const long SCE_POWERSHELL_DEFAULT = 0;
        const long SCE_POWERSHELL_COMMENT = 1;
        const long SCE_POWERSHELL_STRING = 2;
        const long SCE_POWERSHELL_CHARACTER = 3;
        const long SCE_POWERSHELL_NUMBER = 4;
        const long SCE_POWERSHELL_VARIABLE = 5;
        const long SCE_POWERSHELL_OPERATOR = 6;
        const long SCE_POWERSHELL_IDENTIFIER = 7;
        const long SCE_POWERSHELL_KEYWORD = 8;
        const long SCE_POWERSHELL_CMDLET = 9;
        const long SCE_POWERSHELL_ALIAS = 10;
        const long SCE_POWERSHELL_FUNCTION = 11;
        const long SCE_POWERSHELL_USER1 = 12;
        const long SCE_POWERSHELL_COMMENTSTREAM = 13;
        const long SCE_POWERSHELL_HERE_STRING = 14;
        const long SCE_POWERSHELL_HERE_CHARACTER = 15;
        const long SCE_POWERSHELL_COMMENTDOCKEYWORD = 16;
        const long SCE_MYSQL_DEFAULT = 0;
        const long SCE_MYSQL_COMMENT = 1;
        const long SCE_MYSQL_COMMENTLINE = 2;
        const long SCE_MYSQL_VARIABLE = 3;
        const long SCE_MYSQL_SYSTEMVARIABLE = 4;
        const long SCE_MYSQL_KNOWNSYSTEMVARIABLE = 5;
        const long SCE_MYSQL_NUMBER = 6;
        const long SCE_MYSQL_MAJORKEYWORD = 7;
        const long SCE_MYSQL_KEYWORD = 8;
        const long SCE_MYSQL_DATABASEOBJECT = 9;
        const long SCE_MYSQL_PROCEDUREKEYWORD = 10;
        const long SCE_MYSQL_STRING = 11;
        const long SCE_MYSQL_SQSTRING = 12;
        const long SCE_MYSQL_DQSTRING = 13;
        const long SCE_MYSQL_OPERATOR = 14;
        const long SCE_MYSQL_FUNCTION = 15;
        const long SCE_MYSQL_IDENTIFIER = 16;
        const long SCE_MYSQL_QUOTEDIDENTIFIER = 17;
        const long SCE_MYSQL_USER1 = 18;
        const long SCE_MYSQL_USER2 = 19;
        const long SCE_MYSQL_USER3 = 20;
        const long SCE_MYSQL_HIDDENCOMMAND = 21;
        const long SCE_MYSQL_PLACEHOLDER = 22;
        const long SCE_PO_DEFAULT = 0;
        const long SCE_PO_COMMENT = 1;
        const long SCE_PO_MSGID = 2;
        const long SCE_PO_MSGID_TEXT = 3;
        const long SCE_PO_MSGSTR = 4;
        const long SCE_PO_MSGSTR_TEXT = 5;
        const long SCE_PO_MSGCTXT = 6;
        const long SCE_PO_MSGCTXT_TEXT = 7;
        const long SCE_PO_FUZZY = 8;
        const long SCE_PO_PROGRAMMER_COMMENT = 9;
        const long SCE_PO_REFERENCE = 10;
        const long SCE_PO_FLAGS = 11;
        const long SCE_PO_MSGID_TEXT_EOL = 12;
        const long SCE_PO_MSGSTR_TEXT_EOL = 13;
        const long SCE_PO_MSGCTXT_TEXT_EOL = 14;
        const long SCE_PO_ERROR = 15;
        const long SCE_PAS_DEFAULT = 0;
        const long SCE_PAS_IDENTIFIER = 1;
        const long SCE_PAS_COMMENT = 2;
        const long SCE_PAS_COMMENT2 = 3;
        const long SCE_PAS_COMMENTLINE = 4;
        const long SCE_PAS_PREPROCESSOR = 5;
        const long SCE_PAS_PREPROCESSOR2 = 6;
        const long SCE_PAS_NUMBER = 7;
        const long SCE_PAS_HEXNUMBER = 8;
        const long SCE_PAS_WORD = 9;
        const long SCE_PAS_STRING = 10;
        const long SCE_PAS_STRINGEOL = 11;
        const long SCE_PAS_CHARACTER = 12;
        const long SCE_PAS_OPERATOR = 13;
        const long SCE_PAS_ASM = 14;
        const long SCE_SORCUS_DEFAULT = 0;
        const long SCE_SORCUS_COMMAND = 1;
        const long SCE_SORCUS_PARAMETER = 2;
        const long SCE_SORCUS_COMMENTLINE = 3;
        const long SCE_SORCUS_STRING = 4;
        const long SCE_SORCUS_STRINGEOL = 5;
        const long SCE_SORCUS_IDENTIFIER = 6;
        const long SCE_SORCUS_OPERATOR = 7;
        const long SCE_SORCUS_NUMBER = 8;
        const long SCE_SORCUS_CONSTANT = 9;
        const long SCE_POWERPRO_DEFAULT = 0;
        const long SCE_POWERPRO_COMMENTBLOCK = 1;
        const long SCE_POWERPRO_COMMENTLINE = 2;
        const long SCE_POWERPRO_NUMBER = 3;
        const long SCE_POWERPRO_WORD = 4;
        const long SCE_POWERPRO_WORD2 = 5;
        const long SCE_POWERPRO_WORD3 = 6;
        const long SCE_POWERPRO_WORD4 = 7;
        const long SCE_POWERPRO_DOUBLEQUOTEDSTRING = 8;
        const long SCE_POWERPRO_SINGLEQUOTEDSTRING = 9;
        const long SCE_POWERPRO_LINECONTINUE = 10;
        const long SCE_POWERPRO_OPERATOR = 11;
        const long SCE_POWERPRO_IDENTIFIER = 12;
        const long SCE_POWERPRO_STRINGEOL = 13;
        const long SCE_POWERPRO_VERBATIM = 14;
        const long SCE_POWERPRO_ALTQUOTE = 15;
        const long SCE_POWERPRO_FUNCTION = 16;
        const long SCE_SML_DEFAULT = 0;
        const long SCE_SML_IDENTIFIER = 1;
        const long SCE_SML_TAGNAME = 2;
        const long SCE_SML_KEYWORD = 3;
        const long SCE_SML_KEYWORD2 = 4;
        const long SCE_SML_KEYWORD3 = 5;
        const long SCE_SML_LINENUM = 6;
        const long SCE_SML_OPERATOR = 7;
        const long SCE_SML_NUMBER = 8;
        const long SCE_SML_CHAR = 9;
        const long SCE_SML_STRING = 11;
        const long SCE_SML_COMMENT = 12;
        const long SCE_SML_COMMENT1 = 13;
        const long SCE_SML_COMMENT2 = 14;
        const long SCE_SML_COMMENT3 = 15;
        const long SCE_MARKDOWN_DEFAULT = 0;
        const long SCE_MARKDOWN_LINE_BEGIN = 1;
        const long SCE_MARKDOWN_STRONG1 = 2;
        const long SCE_MARKDOWN_STRONG2 = 3;
        const long SCE_MARKDOWN_EM1 = 4;
        const long SCE_MARKDOWN_EM2 = 5;
        const long SCE_MARKDOWN_HEADER1 = 6;
        const long SCE_MARKDOWN_HEADER2 = 7;
        const long SCE_MARKDOWN_HEADER3 = 8;
        const long SCE_MARKDOWN_HEADER4 = 9;
        const long SCE_MARKDOWN_HEADER5 = 10;
        const long SCE_MARKDOWN_HEADER6 = 11;
        const long SCE_MARKDOWN_PRECHAR = 12;
        const long SCE_MARKDOWN_ULIST_ITEM = 13;
        const long SCE_MARKDOWN_OLIST_ITEM = 14;
        const long SCE_MARKDOWN_BLOCKQUOTE = 15;
        const long SCE_MARKDOWN_STRIKEOUT = 16;
        const long SCE_MARKDOWN_HRULE = 17;
        const long SCE_MARKDOWN_LINK = 18;
        const long SCE_MARKDOWN_CODE = 19;
        const long SCE_MARKDOWN_CODE2 = 20;
        const long SCE_MARKDOWN_CODEBK = 21;
        const long SCE_TXT2TAGS_DEFAULT = 0;
        const long SCE_TXT2TAGS_LINE_BEGIN = 1;
        const long SCE_TXT2TAGS_STRONG1 = 2;
        const long SCE_TXT2TAGS_STRONG2 = 3;
        const long SCE_TXT2TAGS_EM1 = 4;
        const long SCE_TXT2TAGS_EM2 = 5;
        const long SCE_TXT2TAGS_HEADER1 = 6;
        const long SCE_TXT2TAGS_HEADER2 = 7;
        const long SCE_TXT2TAGS_HEADER3 = 8;
        const long SCE_TXT2TAGS_HEADER4 = 9;
        const long SCE_TXT2TAGS_HEADER5 = 10;
        const long SCE_TXT2TAGS_HEADER6 = 11;
        const long SCE_TXT2TAGS_PRECHAR = 12;
        const long SCE_TXT2TAGS_ULIST_ITEM = 13;
        const long SCE_TXT2TAGS_OLIST_ITEM = 14;
        const long SCE_TXT2TAGS_BLOCKQUOTE = 15;
        const long SCE_TXT2TAGS_STRIKEOUT = 16;
        const long SCE_TXT2TAGS_HRULE = 17;
        const long SCE_TXT2TAGS_LINK = 18;
        const long SCE_TXT2TAGS_CODE = 19;
        const long SCE_TXT2TAGS_CODE2 = 20;
        const long SCE_TXT2TAGS_CODEBK = 21;
        const long SCE_TXT2TAGS_COMMENT = 22;
        const long SCE_TXT2TAGS_OPTION = 23;
        const long SCE_TXT2TAGS_PREPROC = 24;
        const long SCE_TXT2TAGS_POSTPROC = 25;
        const long SCE_A68K_DEFAULT = 0;
        const long SCE_A68K_COMMENT = 1;
        const long SCE_A68K_NUMBER_DEC = 2;
        const long SCE_A68K_NUMBER_BIN = 3;
        const long SCE_A68K_NUMBER_HEX = 4;
        const long SCE_A68K_STRING1 = 5;
        const long SCE_A68K_OPERATOR = 6;
        const long SCE_A68K_CPUINSTRUCTION = 7;
        const long SCE_A68K_EXTINSTRUCTION = 8;
        const long SCE_A68K_REGISTER = 9;
        const long SCE_A68K_DIRECTIVE = 10;
        const long SCE_A68K_MACRO_ARG = 11;
        const long SCE_A68K_LABEL = 12;
        const long SCE_A68K_STRING2 = 13;
        const long SCE_A68K_IDENTIFIER = 14;
        const long SCE_A68K_MACRO_DECLARATION = 15;
        const long SCE_A68K_COMMENT_WORD = 16;
        const long SCE_A68K_COMMENT_SPECIAL = 17;
        const long SCE_A68K_COMMENT_DOXYGEN = 18;
        const long SCE_MODULA_DEFAULT = 0;
        const long SCE_MODULA_COMMENT = 1;
        const long SCE_MODULA_DOXYCOMM = 2;
        const long SCE_MODULA_DOXYKEY = 3;
        const long SCE_MODULA_KEYWORD = 4;
        const long SCE_MODULA_RESERVED = 5;
        const long SCE_MODULA_NUMBER = 6;
        const long SCE_MODULA_BASENUM = 7;
        const long SCE_MODULA_FLOAT = 8;
        const long SCE_MODULA_STRING = 9;
        const long SCE_MODULA_STRSPEC = 10;
        const long SCE_MODULA_CHAR = 11;
        const long SCE_MODULA_CHARSPEC = 12;
        const long SCE_MODULA_PROC = 13;
        const long SCE_MODULA_PRAGMA = 14;
        const long SCE_MODULA_PRGKEY = 15;
        const long SCE_MODULA_OPERATOR = 16;
        const long SCE_MODULA_BADSTR = 17;
        const long SCE_COFFEESCRIPT_DEFAULT = 0;
        const long SCE_COFFEESCRIPT_COMMENT = 1;
        const long SCE_COFFEESCRIPT_COMMENTLINE = 2;
        const long SCE_COFFEESCRIPT_COMMENTDOC = 3;
        const long SCE_COFFEESCRIPT_NUMBER = 4;
        const long SCE_COFFEESCRIPT_WORD = 5;
        const long SCE_COFFEESCRIPT_STRING = 6;
        const long SCE_COFFEESCRIPT_CHARACTER = 7;
        const long SCE_COFFEESCRIPT_UUID = 8;
        const long SCE_COFFEESCRIPT_PREPROCESSOR = 9;
        const long SCE_COFFEESCRIPT_OPERATOR = 10;
        const long SCE_COFFEESCRIPT_IDENTIFIER = 11;
        const long SCE_COFFEESCRIPT_STRINGEOL = 12;
        const long SCE_COFFEESCRIPT_VERBATIM = 13;
        const long SCE_COFFEESCRIPT_REGEX = 14;
        const long SCE_COFFEESCRIPT_COMMENTLINEDOC = 15;
        const long SCE_COFFEESCRIPT_WORD2 = 16;
        const long SCE_COFFEESCRIPT_COMMENTDOCKEYWORD = 17;
        const long SCE_COFFEESCRIPT_COMMENTDOCKEYWORDERROR = 18;
        const long SCE_COFFEESCRIPT_GLOBALCLASS = 19;
        const long SCE_COFFEESCRIPT_STRINGRAW = 20;
        const long SCE_COFFEESCRIPT_TRIPLEVERBATIM = 21;
        const long SCE_COFFEESCRIPT_HASHQUOTEDSTRING = 22;
        const long SCE_COFFEESCRIPT_VERBOSE_REGEX = 23;
        const long SCE_COFFEESCRIPT_VERBOSE_REGEX_COMMENT = 24;
        const long SCE_COFFEESCRIPT_COMMENTBLOCK = 25;
        const long SCE_AVS_DEFAULT = 0;
        const long SCE_AVS_COMMENTBLOCK = 1;
        const long SCE_AVS_COMMENTBLOCKN = 2;
        const long SCE_AVS_COMMENTLINE = 3;
        const long SCE_AVS_NUMBER = 4;
        const long SCE_AVS_OPERATOR = 5;
        const long SCE_AVS_IDENTIFIER = 6;
        const long SCE_AVS_STRING = 7;
        const long SCE_AVS_TRIPLESTRING = 8;
        const long SCE_AVS_KEYWORD = 9;
        const long SCE_AVS_FILTER = 10;
        const long SCE_AVS_PLUGIN = 11;
        const long SCE_AVS_FUNCTION = 12;
        const long SCE_AVS_CLIPPROP = 13;
        const long SCE_AVS_USERDFN = 14;
        const long SCE_ECL_DEFAULT = 0;
        const long SCE_ECL_COMMENT = 1;
        const long SCE_ECL_COMMENTLINE = 2;
        const long SCE_ECL_NUMBER = 3;
        const long SCE_ECL_STRING = 4;
        const long SCE_ECL_WORD0 = 5;
        const long SCE_ECL_OPERATOR = 6;
        const long SCE_ECL_CHARACTER = 7;
        const long SCE_ECL_UUID = 8;
        const long SCE_ECL_PREPROCESSOR = 9;
        const long SCE_ECL_UNKNOWN = 10;
        const long SCE_ECL_IDENTIFIER = 11;
        const long SCE_ECL_STRINGEOL = 12;
        const long SCE_ECL_VERBATIM = 13;
        const long SCE_ECL_REGEX = 14;
        const long SCE_ECL_COMMENTLINEDOC = 15;
        const long SCE_ECL_WORD1 = 16;
        const long SCE_ECL_COMMENTDOCKEYWORD = 17;
        const long SCE_ECL_COMMENTDOCKEYWORDERROR = 18;
        const long SCE_ECL_WORD2 = 19;
        const long SCE_ECL_WORD3 = 20;
        const long SCE_ECL_WORD4 = 21;
        const long SCE_ECL_WORD5 = 22;
        const long SCE_ECL_COMMENTDOC = 23;
        const long SCE_ECL_ADDED = 24;
        const long SCE_ECL_DELETED = 25;
        const long SCE_ECL_CHANGED = 26;
        const long SCE_ECL_MOVED = 27;
        const long SCE_OSCRIPT_DEFAULT = 0;
        const long SCE_OSCRIPT_LINE_COMMENT = 1;
        const long SCE_OSCRIPT_BLOCK_COMMENT = 2;
        const long SCE_OSCRIPT_DOC_COMMENT = 3;
        const long SCE_OSCRIPT_PREPROCESSOR = 4;
        const long SCE_OSCRIPT_NUMBER = 5;
        const long SCE_OSCRIPT_SINGLEQUOTE_STRING = 6;
        const long SCE_OSCRIPT_DOUBLEQUOTE_STRING = 7;
        const long SCE_OSCRIPT_CONSTANT = 8;
        const long SCE_OSCRIPT_IDENTIFIER = 9;
        const long SCE_OSCRIPT_GLOBAL = 10;
        const long SCE_OSCRIPT_KEYWORD = 11;
        const long SCE_OSCRIPT_OPERATOR = 12;
        const long SCE_OSCRIPT_LABEL = 13;
        const long SCE_OSCRIPT_TYPE = 14;
        const long SCE_OSCRIPT_FUNCTION = 15;
        const long SCE_OSCRIPT_OBJECT = 16;
        const long SCE_OSCRIPT_PROPERTY = 17;
        const long SCE_OSCRIPT_METHOD = 18;
        const long SCE_VISUALPROLOG_DEFAULT = 0;
        const long SCE_VISUALPROLOG_KEY_MAJOR = 1;
        const long SCE_VISUALPROLOG_KEY_MINOR = 2;
        const long SCE_VISUALPROLOG_KEY_DIRECTIVE = 3;
        const long SCE_VISUALPROLOG_COMMENT_BLOCK = 4;
        const long SCE_VISUALPROLOG_COMMENT_LINE = 5;
        const long SCE_VISUALPROLOG_COMMENT_KEY = 6;
        const long SCE_VISUALPROLOG_COMMENT_KEY_ERROR = 7;
        const long SCE_VISUALPROLOG_IDENTIFIER = 8;
        const long SCE_VISUALPROLOG_VARIABLE = 9;
        const long SCE_VISUALPROLOG_ANONYMOUS = 10;
        const long SCE_VISUALPROLOG_NUMBER = 11;
        const long SCE_VISUALPROLOG_OPERATOR = 12;
        const long SCE_VISUALPROLOG_CHARACTER = 13;
        const long SCE_VISUALPROLOG_CHARACTER_TOO_MANY = 14;
        const long SCE_VISUALPROLOG_CHARACTER_ESCAPE_ERROR = 15;
        const long SCE_VISUALPROLOG_STRING = 16;
        const long SCE_VISUALPROLOG_STRING_ESCAPE = 17;
        const long SCE_VISUALPROLOG_STRING_ESCAPE_ERROR = 18;
        const long SCE_VISUALPROLOG_STRING_EOL_OPEN = 19;
        const long SCE_VISUALPROLOG_STRING_VERBATIM = 20;
        const long SCE_VISUALPROLOG_STRING_VERBATIM_SPECIAL = 21;
        const long SCE_VISUALPROLOG_STRING_VERBATIM_EOL = 22;
        const long SCE_STTXT_DEFAULT = 0;
        const long SCE_STTXT_COMMENT = 1;
        const long SCE_STTXT_COMMENTLINE = 2;
        const long SCE_STTXT_KEYWORD = 3;
        const long SCE_STTXT_TYPE = 4;
        const long SCE_STTXT_FUNCTION = 5;
        const long SCE_STTXT_FB = 6;
        const long SCE_STTXT_NUMBER = 7;
        const long SCE_STTXT_HEXNUMBER = 8;
        const long SCE_STTXT_PRAGMA = 9;
        const long SCE_STTXT_OPERATOR = 10;
        const long SCE_STTXT_CHARACTER = 11;
        const long SCE_STTXT_STRING1 = 12;
        const long SCE_STTXT_STRING2 = 13;
        const long SCE_STTXT_STRINGEOL = 14;
        const long SCE_STTXT_IDENTIFIER = 15;
        const long SCE_STTXT_DATETIME = 16;
        const long SCE_STTXT_VARS = 17;
        const long SCE_STTXT_PRAGMAS = 18;
        const long SCE_XML_DEFAULT = 0;
        const long SCE_XML_PROLOG = 0;
        const long SCE_XML_START_TAG_OPEN = 1;
        const long SCE_XML_START_TAG_NAME = 2;
        const long SCE_XML_START_TAG_CLOSE = 3;
        const long SCE_XML_START_TAG_EMPTY_CLOSE = 4;
        const long SCE_XML_START_TAG_ATTR_NAME = 5;
        const long SCE_XML_START_TAG_ATTR_EQUALS = 6;
        const long SCE_XML_START_TAG_ATTR_QUOT_OPEN = 7;
        const long SCE_XML_START_TAG_ATTR_QUOT_CONTENT = 8;
        const long SCE_XML_START_TAG_ATTR_QUOT_CLOSE = 9;
        const long SCE_XML_START_TAG_ATTR_APOS_OPEN = 10;
        const long SCE_XML_START_TAG_ATTR_APOS_CONTENT = 11;
        const long SCE_XML_START_TAG_ATTR_APOS_CLOSE = 12;
        const long SCE_XML_END_TAG_OPEN = 13;
        const long SCE_XML_END_TAG_NAME = 14;
        const long SCE_XML_END_TAG_CLOSE = 15;
        const long SCE_XML_START_TAG_ATTR_NUMBER = 16;
        const long SCE_XML_ENTITY_REF = 17;
        const long SCE_XML_CHAR_REF = 18;
        const long SCE_XML_DATA_NEWLINE = 19;
        const long SCE_XML_DATA_CHARS = 20;
        const long SCE_XML_CDATA_SECT_OPEN = 21;
        const long SCE_XML_CDATA_SECT_CONTENT = 22;
        const long SCE_XML_CDATA_SECT_CLOSE = 23;
        const long SCE_XML_COMMENT_OPEN = 24;
        const long SCE_XML_COMMENT_CONTENT = 25;
        const long SCE_XML_COMMENT_CLOSE = 26;
        const long SCE_XML_PI_OPEN = 27;
        const long SCE_XML_PI_CONTENT = 28;
        const long SCE_XML_PI_CLOSE = 29;
        const long SCE_XML_XML_DECL_OPEN = 30;
        const long SCE_XML_XML_DECL_CONTENT = 31;
        const long SCE_XML_XML_DECL_CLOSE = 40;
        const long SCE_XML_BOM = 41;
        const long SCE_XPATH_TAG_NAME = 42;
        const long SCE_XPATH_ATTR_NAME = 43;
        const long SCE_XPATH_OPEN = 44;
        const long SCE_XPATH_CONTENT_QUOT = 45;
        const long SCE_XPATH_CONTENT_APOS = 46;
        const long SCE_XPATH_CLOSE = 47;
        const long SCE_XML_START_TAG_WHITE_SPACE = 48;
        const long SCE_XML_START_TAG_ATTR_UNQUOTED = 49;
        const long SCE_XML_END_TAG_WHITE_SPACE = 50;
        const long SCE_XML_DECLARATION_OPEN = 51;
        const long SCE_XML_DECLARATION_TYPE = 52;
        const long SCE_XML_DECLN_WHITE_SPACE = 53;
        const long SCE_XML_DECLN_NAME = 54;
        const long SCE_XML_DECLN_CLOSE = 55;
        const long SCE_XML_DECLN_QUOT_CONTENT = 56;
        const long SCE_XML_DECLN_APOS_CONTENT = 57;
        const long SCE_XML_DECLN_DATA_CHARS = 58;
        const long SCE_XML_UPPER_BOUND = 59;
        const long SCE_UDL_M_DEFAULT = 0;
        const long SCE_UDL_M_STAGO = 1;
        const long SCE_UDL_M_TAGNAME = 2;
        const long SCE_UDL_M_TAGSPACE = 3;
        const long SCE_UDL_M_ATTRNAME = 4;
        const long SCE_UDL_M_OPERATOR = 5;
        const long SCE_UDL_M_STAGC = 6;
        const long SCE_UDL_M_EMP_TAGC = 7;
        const long SCE_UDL_M_STRING = 8;
        const long SCE_UDL_M_ETAGO = 9;
        const long SCE_UDL_M_ETAGC = 10;
        const long SCE_UDL_M_ENTITY = 11;
        const long SCE_UDL_M_PI = 12;
        const long SCE_UDL_M_CDATA = 13;
        const long SCE_UDL_M_COMMENT = 14;
        const long SCE_UDL_CSS_DEFAULT = 15;
        const long SCE_UDL_CSS_COMMENT = 16;
        const long SCE_UDL_CSS_NUMBER = 17;
        const long SCE_UDL_CSS_STRING = 18;
        const long SCE_UDL_CSS_WORD = 19;
        const long SCE_UDL_CSS_IDENTIFIER = 20;
        const long SCE_UDL_CSS_OPERATOR = 21;
        const long SCE_UDL_CSL_DEFAULT = 22;
        const long SCE_UDL_CSL_COMMENT = 23;
        const long SCE_UDL_CSL_COMMENTBLOCK = 24;
        const long SCE_UDL_CSL_NUMBER = 25;
        const long SCE_UDL_CSL_STRING = 26;
        const long SCE_UDL_CSL_WORD = 27;
        const long SCE_UDL_CSL_IDENTIFIER = 28;
        const long SCE_UDL_CSL_OPERATOR = 29;
        const long SCE_UDL_CSL_REGEX = 30;
        const long SCE_UDL_SSL_DEFAULT = 31;
        const long SCE_UDL_SSL_COMMENT = 40;
        const long SCE_UDL_SSL_COMMENTBLOCK = 41;
        const long SCE_UDL_SSL_NUMBER = 42;
        const long SCE_UDL_SSL_STRING = 43;
        const long SCE_UDL_SSL_WORD = 44;
        const long SCE_UDL_SSL_IDENTIFIER = 45;
        const long SCE_UDL_SSL_OPERATOR = 46;
        const long SCE_UDL_SSL_REGEX = 47;
        const long SCE_UDL_SSL_VARIABLE = 48;
        const long SCE_UDL_TPL_DEFAULT = 49;
        const long SCE_UDL_TPL_COMMENT = 50;
        const long SCE_UDL_TPL_COMMENTBLOCK = 51;
        const long SCE_UDL_TPL_NUMBER = 52;
        const long SCE_UDL_TPL_STRING = 53;
        const long SCE_UDL_TPL_WORD = 54;
        const long SCE_UDL_TPL_IDENTIFIER = 55;
        const long SCE_UDL_TPL_OPERATOR = 56;
        const long SCE_UDL_TPL_VARIABLE = 57;
        const long SCE_UDL_UPPER_BOUND = 57;
        const long SC_LINE_END_TYPE_DEFAULT = 0;
        const long SC_LINE_END_TYPE_UNICODE = 1;
        const long SC_CP_DBCS = 1;

};
